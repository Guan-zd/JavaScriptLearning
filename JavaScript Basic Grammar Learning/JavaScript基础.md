# JavaScript基础语法

## 1 初识JavaScript

### 1.1 JavaScript历史

- 布兰登·艾奇 Brendan Eich 1961
- 1995年完成设计
- LiveScript --- JavaScript

### 1.2 JavaScript是什么

- 世界上最流行的语言之一， 是一种运行在客户端的脚本语。
- 脚本语言：不与要编译，运行过程中由js解释器逐行来进行解释并执行。
- 基于Node.js技术进行服务器端编程。

### 1.3 JavaScript的作用

- 表单动态验证
- 网页特效
- 表单动态验证
- 服务端开发 Node.js
- 表桌面程序 Electron
- App Cordova
- 控制硬件-物联网 Ruff
- 游戏开发 cocos3d-js

### 1.4 HTML/CSS/JS的关系

- html决定网页结构和内容--看到什么
- css决定网页呈现给用户的模样--好不好看
- 实现业务逻辑与页面控制--决定功能

### 1.5 浏览器执行JS简介

**浏览器分成两部分 渲染引擎与JS引擎**

- 渲染引擎：用来解析HTML与CSS，俗称内核，例如chrome-->blink
- JS引擎：JS解释器，用来读取网页中的JavaScript代码，对其处理后运行，例如chrome-->V8

**浏览器本身并不会执行JIS代码，而是通过内置JavaScript引擎(解释器)来执行JS代码。JS引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以JavaScript语言归为脚本语言，会逐行解释执行。**

### 1.6 JS组成

**JS基础**

- ECMAScript : Javascript语法

#### 1.6.1 ECMAScript 

- ECMAScript是由ECMA国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和扩展。
- ECMAScript : ECMAScript规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。
- 更多参看MDN: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JlavaScript technologies_overview

**JSApi**

- DOM : 页面文档对象模型

#### 1.6.2 DOM——文档对象模型

- 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)。

- BOM : 浏览器对象模型

#### 1.6.3 BOM——浏览器对象模型

- BOM(Browser Object Model，简称BOM)是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。

### 1.7 JS初体验

**JS有3种书写位置，分别为行内、内嵌和外部**。

#### 1.7.1 行内式JS

- <input tyre="button" value="点我试试" onclick="alert (' Hello world')" />
- 可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性），如: onclick
- 注意单双引号的使用:在HTML中我们推荐使用双引号,JS中我们推荐使用单引号
- 可读性差，在html中编写JS大星代码时，不方便阅读;
- 引号易错，引号多层嵌套匹配时，非常容易弄混;
- 特殊情况下使用

#### 1.7.2 内嵌式JS

- <script>alert ( "Hello world~! " ) ;</script>

- 可以将多行JS代码写到<script>标签中

- 内嵌JS是学习时常用的方式

#### 1.7.3 外部JS文件

- <script src="my.js"></script>

- 利于HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观，也方便文件级别的复用

- 引用外部JS文件的script标签中间不可以写代码

- 适合于JS代码量比较大的情况

## 2 JavaScript注释

-  1.单行注释 ctrl + /

-  2.多行注释 shift + alt + a

-  3.vscode修改-首选项-键盘快捷键

## 3 JavaScript输入输出语句

- 为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下∶
- 方法                           说明                                                 归属
- alert(msg)                  浏览器弹出警示框                            浏览器
- console.log(msg)      浏览器控制台打印输出信息               浏览器
- prompt(info)              浏览器弹出输入框，用户可以输入    浏览器

## 4 变量

### 4.1 变量概述

#### 4.1.1 什么是变量

- 用于存放数据的容器，我们通过变量名获取数据，甚至数据可以修改。

#### 4.1.2 变量在内存中的存储

- 本质：变量是程序在内存中申请的一块用来存放数据的空间

### 4.2 变量的使用

- 声明变量
- 赋值

#### 4.2.1 声明变量

```javascript
var age;
```

- var是一个JS关键字，用来声明变量(variable变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管
- age是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间

#### 4.2.2 赋值

```js
age = 10
```

- =用来把右边的值赋给左边的变量空间中 此处代表赋值的意思
- 变量值是程序员保存到变量空间里的值

### 4.3 变量的初始化

```js
var age = 18;
```

- 声明一个变量并赋值，我们称之为变量的初始化。

### 4.4 变量语法扩展

#### 4.4.1 更新变量

- —个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。

#### 4.4.2 声明多个变量

- 同时声明多个变量时，只需要写一个var，多个变量名之间使用英文逗号隔开。

```js
var age = 18, gz = 3000, address = 'wuhan'
```

#### 4.4.3 声明变量的特殊情况

- 只声明不赋值---undefined
- 不声明不赋值---error
- 不声明直接赋值--value

```javascript
 // 只声明不赋值
 var sex
 console.log(sex);//undefined

//不声明不赋值
console.log(tel);//error

//不声明直接赋值
qq = 1000
console.log();//1000
```

### 4.5 变量命名规范

- 由字母(A-Za-z)、数字(O-9)、下划线(_)、美元符号($)组成，如: usrAge, num01,name严格区分大小写。var app;和var App;是两个变量
- 不能以数字开头。18age是错误的
- 不能是关键字、保留字。例如: var、for、while
- 变量名必须有意义。MMD BBDnl→age
- 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName推荐翻译网站:有道爱词霸

### 4.6 小结

- 为什么需要变量?---因为我们一些数据需要保存，所以需要变量
- 变量是什么?---变量就是一个容器，用来存放数据的。方便我们以后使用里面的数据
- 变量的本质是什么?---变量是内存里的一块空间，用来存储数据。
- 变量怎么使用的?---我们使用变量的时候，一定要声明变量，然后赋值，声明变量本质是去内存申请空间。
- 什么是变量的初始化?---声明变量并赋值我们称之为变量的初始化
- 变量命名规范有哪些?交换2个变量值的思路?---变量名尽量要规范,见名知意—驼峰命名法，区分哪些变量名不合法

## 5 数据类型

### 5.1 数据类型的简介

#### 5.1.1 为什么需要

- 在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。

#### 5.1.2 变量的数据类型

- 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。
- 在代码运行时，变量的数据类型是由JS引擎根据=右边变量值的数据类型来判断的，运行完毕之后，变量就确定了数据类型。
- JavaScript拥有动态类型，同时也意味着相同的变量可用作不同的类型:

#### 5.1.3 数据类型的分类

**JS把数据类型分为两类∶**

- 简单数据类型( Number, string,Boolean , Undefined,Nul1)

- 复杂数据类型（ object)

### 5.2 简单数据类型

#### 5.2.1 简单数据类型（基本数据类型）

简单数据类型  说明                                                                    				默认值
Number           数字型，包含整型值和浮点型值，如21、0.21  				 0
Boolean          布尔值类型，如true . false，等价于1和0           		 		alse
String              字符串类型，如"张三”注意咱们js 里面，字符串都带引号   ""
Undefined       var a;声明了变量a但是没有给值，此时a = undefined         undefined
Null                 var a = null;声明了变量a 为空值                                          null

#### 5.2.2 数字型Number

- JavaScript数字类型既可以用来保存整数值，也可以保存小数(浮点数）。

```js
var age = 21
var Age = 21.3
```

##### 5.2.2.1 数字型进制

- 最常见的进制有二进制、八进制、十进制、十六进制。

##### 5.2.2.2 数字型范围

- 最大值 1.7976931348623157e+308
- 最小值 5e-324

##### 5.2.2.3 数字型的三个特殊值

- lnfinity ,代表无穷大，大于任何数值
- -lnfinity ，代表无穷小，小于任何数值
- NaN ,Not a number ，代表一个非数值

##### 5.2.2.4 isNaN()

- 用来判断一个变量是否为非数字的类型，返回true或者false
- isNaN(）这个方法用来判断非数字――并且返回一个值 如果是数字返回的是 false 如果不是数字返回的是true

#### 5.2.3 字符串型string

- 字符串型可以是引号中的任意文本，其语法为双引号""和单引号''

```js
var strMsg ="我爱北京天安门~"; //使用双引号表示字符串
var strMsg2 ='我爱吃猪蹄~';//使用单引号表示字符串
//常见错误
var strMsg3 =我爱大时子; //报错，没使用引号，会被认为是js代码，但js没有这些语法
```

- 
  因为HTML标签里面的属性使用的是双引号，JS这里我们更推荐使用单引号。

##### 5.2.3.1 字符串引号嵌套

- JS可以用单引号嵌套双引号，或者用双引号嵌套单引号(外双内单，外单内双)

```js
var strMsg ='我是"高帅富"程序猿'; //可以用'包含""
var strMsg2="我是'高帅富'程序猿";//也可以用""包含”
//常见错误
var badQuotes = 'What on earth?"; //报错，不能单双引号搭配
```

##### 5.2.3.2 字符串转义符

- 类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。

- 转义符都是\开头的，常用的转义符及其说明如下∶

| 转义符 | 解释说明                  |
| ------ | ------------------------- |
| \n     | 换行符， n时newline的意思 |
| \\     | 斜杠\                     |
| \'     | ' 单引号                  |
| \"     | " 双引号                  |
| \t     | tab缩进                   |
| \b     | 空格， b时blank的意思     |

##### 5.2.3.3 字符串长度

- 字符串是由若千字符组成的，这些字符的数量就是字符串的长度。通过字符串的length属性可以获取整个字符串的长度。

```js
var strMsg = "我是帅气多金的程序猿!";alert (strMsg. length) ; //显示 11
```

##### 5.2.3.4 字符串拼接

- 多个字符串之间可以使用＋进行拼接，其拼接方式为字符串＋任何类型=拼接之后的新字符串
- 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串

```js
//1.1字符串"相加"
alert ( 'hello' + '' + 'world ' ) ; // hello world //1.2数值字符串"相加”
alert ( '100'+ '100') ; l 100100l l 1.3数值字符串＋数值
alert( '11. +12);
//12
```

-  +号总结口诀：数值相加，字符相连

##### 5.2.3.5 字符串拼接加强

```js
console.log ( 'pink老师+ 18') ;
//只要有字符就会相连
var age = 18;
//console.log ( 'pink老师age岁啦');
//这样不行哦
console.log ('pink老师'+ age') ;
//pink老师18
console.log ( 'pink老师' + age + '岁啦');
//pink老师18岁啦
```

- 我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值
- 变呈是不能添加引号的，因为加|号的变量会变成字符串
- 加果变量两侧都有字符串拼接，口诀“引引加功”，删掉数字，变量写加中间

#### 5.2.4 布尔型 Boolean

- 布尔类型有两个值: true和false ，其中 true表示真(对），而false表示假(错)。
- 布尔型和数字型相加的时候，true的值为1 ,false的值为0。

```js
console. log (true + 1); // 2
console. log ( false + 1); // 1
```

#### 5.2.5 Undefined和Null

- 一个声明后没有被赋值的变量会有一个默认值undefined(如果进行相连或者相加时，注意结果)

```js
var variable;
console. log (variable) ;// undefined
console. log ( '你好' +variable) ; //你好undefined
console.log (11 + variable) ;// NaN
console.log(true + variable) ;// lNaN

```

- 一个声明变量给null值，里面存的值为空（学习对象时，我们继续研究null)

```js
var vari = null;
console.log ( "你好' + vari) ; //你好null
console. log ( 11 + vari) ;// 11
console.log (true + vari) ;// 1

```

### 5.3 获取检测变量的数据类型

#### 5.3.1 获取检测变量的数据类型

- typeof可用来获取检测变量的数据类型

```js
var num211 = 10
console.log(typeof(num211));//number
var str211 = 'test'
console.log(typeof(str211));//string
var flag211 = true
console.log(typeof(flag211));//boolean
var vari211 = undefined
console.log(typeof(vari211));//undefined
var timer211 = null
console.log(typeof(timer211));//object
```

#### 5.3.2 字面量

- 字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。
  - 数字字面量:8,9,10
  - 字符串字面量:黑马程序员',"大前端"
  - 布尔字面量: true , false

### 5.4 数据类型转换

#### 5.4.1 什么是数据类型转换

- 使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗染说，就是把一种数据类型的变量转换成另外一种数据类型。
- 我们通常会实现3种方式的转换∶
  - 转换为字符串类型
  - 转换为数字型
  - 转换为布尔型

#### 5.4.2 转换为字符串

| 方式           | 说明                         | 案例                               |
| -------------- | ---------------------------- | ---------------------------------- |
| toString()     | 转成字符串                   | var num=1; alert(num.toString())   |
| String强制转换 | 转成字符串                   | var num=1; alert(num.String())     |
| 加号拼接字符串 | 和字符串拼接的结果都是字符串 | var num=1; alert(num+'我是字符串') |

- oString0和String0使用方式不一样。
- 三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一种方式也称之为隐式转换。

#### 5.4.3 转换为数字型
| 方式                   | 说明                         | 案例                |
| ---------------------- | ---------------------------- | ------------------- |
| parselnt(string)函数   | 将string类型转成整数数值型   | parselnt("78')      |
| parseFloat(string)函数 | 将string类型转成浮点数数值型 | parseFloat('78.21') |
| Number()强制转换函数   | 将string类型转换为数值型     | Number(12')         |
| js隐式转换( - * l )    | 利用算术运算隐式转换为数值型 | '12' -0             |

#### 5.4.4 转换为布尔型
| 方式            | 说明                 | 案例           |
| --------------- | -------------------- | -------------- |
| Boolean函数函数 | 将其它类型转成布尔型 | Bolean('true') |

- 代表空、否定的值会被转换为false ，如"、0、NaN、 null、undefined
- 其余值会被转换为true

### 5.5 拓展阅读

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005725938-1542049222.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005753544-1863611358.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005823680-546571103.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005853466-1779377836.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005915959-392837781.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719010005777-45957242.png)

## 6 运算符

- 能够使用常用运算符
- 能够说出前置递增和后置递增的区别
- 能够说出运算符的优先级

### 6.1 运算符

- 运算符( operator )也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。
- JavaScript中常用的运算符有∶
  - 算数运算符
  - 递增和递减运算符
  - 比较运算符
  - 逻辑运算符
  - 赋值运算符

### 6.2 算数运算符

#### 6.2.1 算数运算符概述

- 概念:算术运算使用的符号，用于执行两个变量或值的算术运算。

| 运算符 | 说明 | 案例      |
| ------ | ---- | --------- |
| +      | 加   | 10+20=30  |
| -      | 减   | 10-20=-10 |
| *      | 乘   | 10*20=200 |
| /      | 除   | 10/20=0.5 |
| %      | 取模 | 9%2=1     |
#### 6.2.2 浮点数的精度问题

- 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。

```
var result = 0.1 + 0.2;//结果不是0.3，而是:0.30000000000000004
console.log (0.07 * 100);//结果不是7，而是∶7.000000000000001
```

- 所以∶不要直接判断两个浮点数是否相等!

#### 6.2.3 注意

- 它的余数是0就说明这个数能被整除，这就是%取余运算符的主要用途
- 注意算术运算符优先级的，先乘除，后加减，有小括号先算小括号里面的

#### 6.2.4 表达式和返回值

- 表达式∶是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合
- 简单理解︰是由数字、运算符、变量等组成的式子

### 6.3 递增和递减运算符

#### 6.3.1 递增和递减运算符概述

- 如果需要反复给数字变量添加或减去1，可以使用递增(++)和递减(--)运算符来完成。
- 在JavaScript中，递增（++)和递减(-- )既可以放在变量前面，也可以放在变量后面。
- 放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。

注意：递增和递减运算符必须和变量配合使用

#### 6.3.2 递增运算符

##### 6.3.2.1 前置递增运算符

- ++num前置递增，就是自加1，类似于num = num + 1，但是++num写起来更简单。
- 先自加后返回

##### 6.3.2.2 后置递增运算符

- num++后置递增，就是自加1，类似于num = num +1，但是num++写起来更简单。
- 先返回原值，后自加

前置自增和后置自增如果单独使用效果是一样的

##### 6.3.2.3 总结

- 前置递增和后置递增运算符可以简化代码的编写，让变量的值+1比以前写法更简单
- 单独使用时，运行结果相同
- 与其他代码联用时，执行结果会不同
- 后置:先原值运算，后自加(先人后己)
- 前置:先自加，后运算(先已后人)
- 开发时，大多使用后置递增/减，并且代码独占一行，例如:num++;或者num--;

### 6.4 比较运算符

#### 6.4.1 比较运算符概述

概念︰比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值( true / false )作为比较运算的结果。

| 运算符名称 | 说明                      |
| ---------- | ------------------------- |
| <          | 小于号                    |
| >          | 大于号                    |
| >=         | 大于等于号                |
| <=         | 小于等于号                |
| ==         | 判等号（会转型）          |
| !=         | 不等号                    |
| === !==    | 全等 要求值和数据类型一致 |

#### 6.4.2 总结

| 符号 | 作用 | 用法                                     |
| ---- | ---- | ---------------------------------------- |
| =    | 赋值 | 把右边给左边                             |
| ==   | 判断 | 判断两边值是否相等（注意此时有隐式转换） |
| ===  | 全等 | 判断两边的值和数据类型是否完全相同       |



### 6.5 逻辑运算符

#### 6.5.1 逻辑运算符概述

概念∶逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断

| 逻辑运算符 | 说明           | 案例            |
| ---------- | -------------- | --------------- |
| &&         | 逻辑与=>与 and | true && false   |
| \|\|       | 逻辑或=>或 or  | true \|\| false |
| !          | 逻辑非=>非 not | !true           |

#### 6.5.2 逻辑与&&

两边都是true才返回true，否则返回false

#### 6.5.3 逻辑或 ||

两边都为false才返回false，否则都为true

#### 6.5.4 逻辑非 ！

逻辑非(!)也叫作取反符，用来取一个布尔值相反的值，如true的相反值是false

#### 6.5.5 短路运算（逻辑中断）

- 短路运算的原理︰当有多个表达式(值)时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值
- 1.逻辑与
  - 语法∶表达式1&&表达式2
  - 如果第一个表达式的值为真，则返回表达式2如果第一个表达式的值为假，则返回表达式1
- 逻辑或
  - 语法:表达式1||表达式2
  - 如果第一个表达式的值为真，则返回表达式1如果第一个表达式的值为假，则返回表达式2

### 6.6 赋值运算符

**概念：用来把数据赋值给变量的运算符**
| 赋值运算符 | 说明                 | 案例                |
| ---------- | -------------------- | ------------------- |
| =          | 直接赋值             | var user='xx'       |
| += -=      | 加、减一个数后再赋值 | var age =10 ;age+=5 |
| *= /= %=   | 乘、除、取模后再赋值 | var age = 2; age*=5 |
### 6.7 运算符优先级

| 优先级 | 运算符     | 顺序            |
| ------ | ---------- | --------------- |
| 1      | 小括号     | ()              |
| 2      | 一元运算符 | ++ -- ！        |
| 3      | 算数运算符 | 先 * / % 后 + - |
| 4      | 关系运算符 | > >= < <=       |
| 5      | 相等运算符 | == != === !==   |
| 6      | 逻辑运算符 | 先&&后\|\|      |
| 7      | 赋值运算符 | =               |
| 8      | 逗号运算符 | ,               |

- 一元运算符里面的逻辑非优先级很高
- 逻辑与比逻辑或优先级高

## 7 流程控制

### 7.1 流程控制概述

- 在一个程序执行的过程中,各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码
  的执行顺序来实现我们要完成的功能。
- 简单理解:流程控制就是来控制我们的代码按照什么结构顺序来执行
- 流程控制主要有三种结构,分别是顺序结构、分支结构和循环结构,这三种结构代表三种代码执行的顺序。

### 7.2 顺序流程控制

顺序结构是程序中最简单、最基本的流程控制 ,它没有特定的语法结构,程序会按照代码的先后顺序,依次执行,
程序中大多数的代码都是这样执行的。

### 7.3 分支流程控制

#### 7.3.1 分支结构

由上到下执行代码的过程中,根据不同的条件,执行不同的路径代码(执行代码多选一的过程) , 从而得到不同的结果

JS语言提供了两种分支结构语句

- if语句
- switch 语句

#### 7.3.2 if分支语句

##### 7.3.2.1 语法结构

```js
//条件成立执行代码 否则什么也不做
if(条件表达式){
	//条件成立执行的代码语句
}
```

语句可以理解为一个行为 ,循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下 ,会分
割成一个一个的语句。

##### 7.3.2.2 执行流程

![](https://img2022.cnblogs.com/blog/2332774/202204/2332774-20220423231647212-2097883354.png)

#### 7.3.3 if else 语句（双分支语句）

##### 7.3.3.1 语法结构

```
//条件成立 执行if里面代码 否则执行else里面的代码
if(条件表达式){
	//[如果]条件成立执行的代码
} else {
	[否则]执行的代码
}
```

##### 7.3.3.2 执行思路

![](https://img2022.cnblogs.com/blog/2332774/202204/2332774-20220423232729748-1658763727.png)

#### 7.3.4 if else if（ 多分支语句）

##### 7.3.4.1 语法结构

```
if(条件一){
    //语句1
} else if(条件二) {
    //语句二
} else {
    //最后的语句
}
```

##### 7.3.4.2 执行流程

![](https://img2022.cnblogs.com/blog/2332774/202204/2332774-20220425155052449-370452807.png)

- 如果条件表达式1满足就执行语句1执行完毕后，退出整个if分支语句
- 如果条件表达式1不满足，则判断条件表达式2满足的话， 执行语句2以此类推
- 如果上面的所有条件表达式都不成立，则执行else 里面的语句

##### 7.3.4.3 注意

- 多分支还是多选一 最后只有一个语句执行
- else if 里面的条件理论上是可以任意多个的
- else if 中间有一个空格

#### 7.3.5 三元表达式

- 三元表达式也能做一些简单的条件选择。
- 有三元运算符组成的式子称为三元表达式

##### 7.3.5.1 语法结构

```
条件表达式 ? 表达式1 :表达式2
```

- 如果条件表达式结果为真则返回表达式1的值如果条件表达式结果为假则返回表达式2的值

#### 7.3.6 switch语句

##### 7.3.6.1 语法结构

- switch语句也是多分支语句,它用于基于不同的条件来执行不同的代码。
- 当要针对变量设置-系列的特定值的选项时,就可以使用switch。

```js
switch (key) {
    case value:
        
        break;

    default:
        break;
}
switch(表达式) {
	case value1:
		//表达式等于value1时要执行的代码
	break;
	case value2:
		//表达式等于value2时要执行的代码
	break;
	default:
		//表达式不等于任何一个value时要执行的代码
}

```

##### 7.3.6.2 执行思路

- 利用我们的表达式的值和case后面的选项值相匹配
- 如果匹配上就执行该case里面的语句
- 如果 都没有匹配上，那么执行default 里面的语句

##### 7.3.6.3 注意事项

- 表达式需要写成变量
- key和value相匹配的时候是全等 必须数据与类型一致
- break如果不设置break则不会退出break 会继续执行下一个case

#### 7.3.7 switcn 与if else if区别

- 一般情况下,它们两个语句可以相互替换
- switch..case语句通常处理case为比较确定值的情况，而...e..语句更加灵活,常用于范围判断(大于、
  等于某个范围)
- switch语句进行条件判断后直接执行到程序的条件语句,效率更高。i而..else 语句有几种条件,就得判断多少次。
- 当分支比较少时, if.. else语句的执行效率比switch语句高。
- 当分支比较多时, switch语句的执行效率比较高,而且结构更清晰。

### 7.4 循环流程控制

#### 7.4.1.循环

- 目的：可以重复执行某些代码

#### 7.4.2.js中的循环

- for循环
- while循环
- do while循环

#### 7.4.3 for循环

- 在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。
- 由循环体及循环的终止条件组成的语句，被称之为循环语句。

##### 7.4.3.1 语法结构

for循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下

```js
for(初始化变量; 条件表达式; 操作表达式){
	//循环体
}
```

- 初始化变量：声明的一个普通变量，通常用于作为计数器使用
- 条件表达式：用来决定每一次循环是否继续执行 就是终止条件
- 操作表达式：是每次循环最后执行的代码 经常用于我们计数器变量进行更新（递增或者递减）

```js
for (let i = 0; i < 100; i++) {
    console.log('执行代码');
}
```

##### 7.4.3.2 执行过程

- 首先执行里面的计数器变量var i = 1  但是这句话在for里面只执行一次index
- 去 i <= 100来判断是否满足条件，如果满足条件︰就去执行循环体,不满足条件退出循环
- 最后去执行i++  i++是单独写的代码 递增 第一轮结束
- 接着去执行i <= 100 如果满足条件 就去执行循环体 不满足条件退出循环 第二轮 以此类推

##### 7.4.3.3 断点调试

- 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，
- 然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行的显示错误，停下。
- 断点调试可以帮我们观察程序的运行过程
- 浏览器中按F12--> sources -->找到需要调试的文件-->在程序的某一行设置断点Watch:监视，
- 通过watch可以监视变量的值的变化，非常的常用。
- F11:程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。
- 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。
- 初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。
- 今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。

##### 7.4.3.4 for循环执行相同/不同代码

```js
for (let i = 0; i < 100; i++) {
    console.log('执行代码');
}
```

- for循环可以重复执行不同的代码 因为有计数器变量i的存在，i每次循环都会变化可以控制执行不同的代码

```js
for(let i=0;i<100;i++){
    console.log('第'+ i +'次执行')
}
```

- 根据i值的不同，做出对应不同的操作与处理
- for循环重复执行某些操作

```js
let init = 0
for (let i = 0; i <= 100; i++) {
    init += i
}
console.log(init);//5050
```

##### 7.4.3.5 双层for循环

很多情况下，单层for循环并不能满足我们的需求，比如我们要打印一个5行5列的图形、打印一个倒直角三角形等，此时就可以通过循环嵌套来实现。

循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例妆在for循环语句中，可以再嵌套一个for 循环，这样的for 循环语句我们称之为双重for循环。

```js
//双重for循环 语法结构
for(外层初始化变量;外层的条件表达式;外层的操作表达式){
  for(内层初始化变量;内层的条件表达式;内层的操作表达式){
    //执行语句
  }
}
//可以把里的循环看作是外层循环的语句
//外层的循环执行一次，里面的循环执行全部
```

```js
for (let i = 0; i < 5; i++) {
    console.log('外层循环', i, '次😁');
    for (let j = 0; j < 5; j++) {
        console.log('内层循环', j, '次😋😎😍');
    }
}
let startStr = ''
//打印五行五列星星
for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5; j++) {
        startStr = startStr + '💕'
    }
    startStr = startStr + '\n'
}
console.log(startStr);

let startStr2 = ''
//打印五行五列星星
for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5 - i; j++) {
        startStr2 = startStr2 + '🎈'
    }
    startStr2 = startStr2 + '\n'
}
console.log(startStr2);

/* 九九乘法表
一共有9行，但是每行的个数不一样，因此需要用到双重for循环外层的 for循环控制行数i，循环9次，可以打印9行
内层的 for循环控制每行公式j
核心算法:每一行公式的个数正好和行数一致，j<= i;每行打印完毕，都需要重新换一行 */
let multiplication = ''
for (let i = 1; i <= 9; i++) {
    for (let j = 1; j <= i; j++) {
        // multiplication = multiplication + '🎗'
        multiplication += j + 'x' + i + '=' + i * j + ' '

    }
    multiplication = multiplication + '\n'
}
console.log(multiplication);
```

##### 7.4.3.6 for循环小结

- for循环可以重复执行某些相同代码
- for循环可以重复执行些许不同的代码，因为我们有计数器
- for循环可以重复执行某些操作，比如算术运算符加法操作
- 随着需求增加，双重for循环可以做更多、更好看的效果
- 双重for循环,外层循环一次，内层for循环全部执行
- for循环是循环条件和数字直接相关的循环
- 分析要比写代码更重要
- 一些核心算法想不到，但是要学会，分析它执行过程
- 举一反三，自己经常总结，做一些相似的案例

#### 7.4.4 while循环

while语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环

##### 7.4.4.1 语法结构

while语句的语法结构如下:
```js
while(条件表达式){
  //循环体代码
}
```
执行思路∶
- 先执行条件表达式，如果结果为true，则执行循环体代码;如果为false，则退出循环，执行后面代码)
- 执行循环体代码
- 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为false 时，整个循环过程才会结束

##### 7.4.4.2 执行过程

执行思路 当条件表达式结果为true 则执行循环体否则退出

```js
let whileNum = 1
while (whileNum < 100) {
    console.log('how are you');
    whileNum++
}
```

#### 7.4.5 do while循环

do... while语句其实是while语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，断则退出循环。

##### 7.4.5.1 语法结构

```js
do {
    //循环体
} while (条件表达式)
```

##### 7.4.5.2 执行过程

执行思路 跟while不同的地方在于 do while 先执行一次循环体 再判断条件
如果条件表达式结果为真 则继续执行代码 否则退出循环

```js
let doI = 1
do {
    console.log('hello');
    doI++
} while (doI <= 100)
```

#### 7.4.6 do 循环小结

- JS中循环有for . while、do while
- 三个循环很多情况下都可以相互替代使用
- 如果是用来计次数，跟数字相关的，三者使用基本相同，但是我们更喜欢用for
- while和do...while可以做更复杂的判断条件，比for循环灵活一些
- while和do...while执行顺序不一样，while先判断后执行，do...while先执行一次，再判断执行
- while和do...while执行次数不一样，do...while至少会执行一次循环体，而while可能一次也不执行
- 实际工作中，我们更常用for循环语句，它写法更简洁直观，所以这个要重点学习

#### 7.4.7 continue break

##### 7.4.7.1 continue 关键字

continue关键字用于立即跳出本次循环，继续下一次循环(本次循环体中continue之后的代码就会少执行一次）。

例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子，其代码实现如下:
```js
for (let i = 1; i <= 5; i++) {
    if (i === 3) {
        continue
    }
    console.log('正在吃第' + i + '个');
}
/*
正在吃第1个
正在吃第2个
正在吃第4个
正在吃第5个
*/
```
##### 7.4.7.2 break 关键字
break 关键字用于立即跳出整个循环（循环结束)。

例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下;

```js
for(let i =1;i<=5;i++){
    if(i===3){
        break;
    }
    console.log('正在吃第'+i+'个包子');
}
/*
正在吃第1个
正在吃第2个
*/
```

### 7.5 JavaScript命名规范以及语法格式

能够知道JS中命名规范规则

能够够书写规范的JS代码

- 标识符命名规范
  - 变量、函数的命名必须要有意义
  - 变量的名称一般用名词
  - 函数的名称一般用动词
- 操作符规范
```js
//操作符的左右两侧各保留一个空格
for (var i = 1; i <= 5; i++){
if (i == 3){
  break; 
  //直接退出整个for循环，跳到整个for循环下面的语句
}
console.log(我正在吃第·+i + "个包子呢");
}
```
- 单行注释规范
```js
for (var i = 1; i <= 5; i++){
  if (i == 3){
    break; 
    //单行注释前面注意有个空格
  }
console.log("我正在吃第·+i + "个包子呢');
}
```
- 其他规范
  - 注意保留空格

## 8 数组

目标：
- 能知道为什么要有数组
- 能够创建数组
- 能够以获取数组中的元素
- 能够对数组进行遍历
- 能够给数组新增一个元素

### 8.1 数组的概念

- 问:之前学习的变量，只能存储一个值。如果我们想存储班级中所有学生的姓名，那么该如何存储呢?
- 答:可以使用数组(Array)。数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。

**什么是数组**∶数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。

```js
1/普通变量一次只能存储一个值
var num = 10;
//数组一次可以存储多个值
var arr =[1,2,3,4,5];
```

### 8.2 创建数组

#### 8.2.1 数组的创建方式

JS中创建数组有两种方式:
- 利用new创建数组
- 利用数组字面量创建数组

#### 8.2.2 利用new创建数组

```js
var 数组名= new Array()
var arr = new Array() ; //创建一个新的空数组
```
#### 8.2.3 利用数组字面量创建数组

```js
//1.数组字面量方式创建空的数组
var 数组名=[ ];
//2．使用数组字面量方式创建带初始值的数组
var 数组名=['小白'，"小黑','大黄"，'瑞奇'l;
```
- 数组的字面量是方括号[]
- 声明数组并赋值称为数组的初始化
- 这种字面量方式也是我们以后最多使用的方式

#### 8.2.4 数组元素类型

数组中可以存放`任意类型`的数据，例如字符串，数字，布尔值等。

### 8.3 获取数组元素

#### 8.3.1 数组的索引

`索引(下标`)∶用来访问数组元素的序号（数组下标从О开始）。

数组可以通过`索引`来访问、设置、修改对应的数组元素，我们可以通过“`数组名[索引`”的形式来获取数组中的元素。
心
这里的`访问`就是获取得到的意思

### 8.4 遍历数组

- 问∶数组中的每一项我们怎么取出来?
- 答:可以通过“数组名[索引引]”的方式一项项的取出来。

- 问:怎么把数组里面的元素全部取出来?
- 规律︰从代码中我们可以发现，从数组中取出每一个元素时，代码是重复的，有所不一样的是索引值在递增 答案就是`循环`

`遍历:`就是把数组中的每个元素从头到尾都访问一次(类似我们每天早上学生的点名）。

```js
//数组的遍历 就是把数组的元素从头到尾访问一遍
let arr2 = ['a', 'b', 'c']
for (let i = 0; i < 3; i++) {
    // i 当作计数器索引来使用
    console.log(arr2[i]);
}
```

#### 8.4.1 数组的长度 

- 数组的长度是元素的个数
- 数组的长度是动态检测数组元素的个数

```js
let arr2 = ['a', 'b', 'c']
console.console.log((arr2.length));//3
```

#### 8.4.2 求数组的和、平均值、最大值
```js
//求数组的平均值与和
let arr3 = [2, 6, 1, 7, 4]
let sum3 = 0
let average3 = 0
for (let i = 0; i < arr3.length; i++) {
    sum3 += arr3[i]
}
console.log('arr3的和是：', sum3);//20
console.log('arr3的平均值是：', sum3 / arr3.length);//4
```

```js
//求数组中的最大值
/**
声明一个保存最大元素的变量max。
默认最大值可以取数组中的第一个元素。
遍历这个数组，把里面每个数组元素和max相比较。
如果这个数组元素大于max就把这个数组元素存到max里面，否则继续下一轮比较。
最后输出这个max。
 */
let arr4 = [2, 6, 1, 77, 52, 25, 7]
let max4 = arr4[0]
for (let i = 1; i < arr4.length; i++) {
    if (arr4[i] > max4) {
        max4 = arr4[i]
    }
}
console.log('arr4的最大值是：',max4);//77
```

#### 8.4.2 数组转换为分割字符串
```js
//数组转换为分割字符串 将数组转换为字符串并使用其它字符串分割
/* 
将数组['red', 'green', 'blue', 'pink']转换为字符串，并且用│或其他符号分割
1.需要一个新变量用于存放转换完的字符串 str。
2.遍历原来的数组，分别把里面数据取出来，加到字符串里面。
3.同时在后面多加一个分隔符
 */
let arr5 = ['red', 'green', 'blue', 'pink']
let str5 = ''
for (let i = 0; i < arr5.length; i++) {
    str5 += arr5[i] + '|' //可以将 | 用变量代替，使用其它任何字符
}
console.log('分割字符串：', str5);//分割字符串： red|green|blue|pink|
```

### 8.5 数组中新增元素

#### 8.5.1 通过修改length长度新增数组元素

- 可以通过修改length长度来实现数组扩容的目的
- length属性是可读写的

```js
let arr1017 = [24, 8, 6, 8]
console.log(arr1017.length);
arr1017.length = 5
console.log(arr1017);//[ 24, 8, 6, 8, <1 empty item> ]
console.log(arr1017[4]);//undefined
```

#### 8.5.2通过修改数组索引新增数组元素

- 可以通过修改数组索引的方式追加数组元素
- 不能直接给数组名赋值，否则会覆盖掉以前的数据

```js
//新增数组元素 修改索引号
//新增数组元素 修改索引号
let arr10172 = ['red', 'green']
arr10172[2] = 'pionk'
console.log(arr10172);//[ 'red', 'green', 'pionk' ]
arr10172[1] = 'blue'
console.log(arr10172);//[ 'red', 'blue', 'pionk' ] 替换原来的元素
arr10172 = '有点意思'
console.log(arr10172);//有点意思 不能直接给数组名赋值，否则会覆盖掉以前的数据
```

#### 8.5.3循环追加数组

```js 
//循环追加数组
/* 
使用循环来追加数组。声明一个空数组arr。
循环中的计数器i可以作为数组元素存入。
由于数组的索引号是从O开始的，因此计数器从О开始更合适，存入的数组元素要+1。
*/
let arr1023 = []
for (let i = 0; i < 10; i++) {
    arr1023[i] = i
}
console.log(arr1023);
// [0, 1, 2, 3, 4,5, 6, 7, 8, 9]
```
#### 8.5.4筛选数组

```js
//筛选数组
let arr10232 = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7]
/* 
声明一个新的数组用于存放新数据newArr 。
遍历原来的旧数组，找出大于等于10的元素。
依次追加给新数组newArr。
*/
let newArr10232 = []
let j = 0
for (let i = 0; i < arr10232.length; i++) {
    if (arr10232[i] >= 10) {
        // newArr10232.push(arr10232[i])
        //新数组从0开始依次递增
        newArr10232[j] = arr10232[i]
        j++
        // newArr10232[newArr10232.length] = arr10232[i]
    }
}
console.log(newArr10232);//[ 77, 52, 25 ]
```

### 8.6 数组的使用操作

#### 8.6.1 数组删除指定元素
```js
/* 
需要一个新数组用于存放筛选之后的数据。
遍历原来的数组，把不是0的数据添加到新数组里面(此时要注意采用数组名+索引的格式接收数据)。
新数组里面的个数,用length不断累加。
*/
let newArr10233 = []
for (let i = 0; i < arr10232.length; i++) {
    if (arr10232[i] != 0) {
        newArr10233[newArr10233.length] = arr10232[i]
    }
}
console.log(newArr10233);//[2,  6, 1, 77,52, 25, 7]
```
#### 8.6.2 翻转数组
- 要求:将数组['red" , 'green", 'blue' , 'pink , 'purple']的内容反过来存放。
- 输出:['purple' , "pink" , 'blue' , ' green', 'red']
```js
let arr10233 = ['red', 'green', 'blue', 'black']
let newArr10234 = []

for (let i = arr10233.length - 1; i >= 0; i--) {
    newArr10234[newArr10234.length] = arr10233[i]
}
console.log(newArr10234);//[ 'black', 'blue', 'green', 'red' ]
```

#### 8.6.3 冒泡排序

`冒泡排序`∶是一种算法，把一系列的数据按照一定的顺序进行排列显示(从小到大或从大到小)。

摘要
- 冒泡排序是一种简单的排序算法。
- 它重复地走访过要排序的数列，一次比较两个元嘉↓如果他们的顺序措误就把他们交换过来。
- 走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
- 这个算法的名字由来是因为越小的元素会经由交换慢慢°浮"到数列的顶端。

```js
let arr10235 = [5, 9, 6, 58, 14, 52, 41, 8]
for (let i = 0; i <= arr10235.length - 1; i++) {// 外层for循环管次数
    for (let j = 0; j <= arr10235.length - i - 1; j++) {// 内层的循环管每一趟交换的次数
        //内部交换2个变量的值 前一个和后面一个数组元素相比较
        // if (arr10235[j] < arr10235[j + 1])
        if (arr10235[j] > arr10235[j + 1]) {
            let temp = arr10235[j]
            arr10235[j] = arr10235[j + 1]
            arr10235[j + 1] = temp
        }
    }
}
console.log(arr10235);//[5,  6,  8,  9,14, 41, 52, 58]
```

## 9 函数

`目标`
- 能够说出为什么需要函数
- 能够根据语法书写函数能够根据需求封装函数
- 能够说出形参和实参的传递过程
- 能够使用函数的返回值
- 能够使用arguments获取函数的参数

`目录`
- 函数的概念
- 函数的使用
- 函数的参数
- 函数的返回值
- arguments的使用
- 函数案例
- 函数的两种声明方式

### 9.1 函数的概念
在JS里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。

虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用JS中的函数。

`函数`∶就是封装了一段`可被重复调用执行的代码块`。通过此代码块可以实现大量代码的重复使用。

```js
// 案例 求数组的累加和
// 1-100 10-50
let sum1111 = 0
for (let i = 1; i <= 100; i++) {
    sum1111 += i
}
console.log(sum1111);//5050

let sum1112 = 0
for (let i = 10; i <= 50; i++) {
    sum1112 += i
}
console.log(sum1112);//1230

//函数方法
function getSum(num1, num2) {
    let sum = 0
    for (let i = num1; i <= num2; i++) {
        sum += i
    }
    console.log(sum);
}
getSum(1, 100)//5050
getSum(10, 50)//1230
```

`目的`：让大量代码重复使用.

### 9.2 函数的使用

函数在使用时分为两步:`声明函数`和`调用函数`。

#### 9.2.1 声明函数

- function是声明函数的关键字,必须小写
- 由于函数一般是为了实现某个功能才定义的，所以通常我们将函数名命名为动词，比如getSum

```js
/* 
function 函数名 () {
    //函数体
}
 */
function sayHi() {
    console.log('hi~~~~');
}
```

#### 9.2.2 调用函数

- 调用的时候千万不要忘记添加小括号。
- 口诀:函数不调用，自己不执行。
注意:声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。

```js
// 函数名()
sayHi()
```
#### 9.2.3 函数的封装

函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口

简单理解︰封装类似于将电脑配件整合组装到机箱中(类似快递打包)

![](https://img2022.cnblogs.com/blog/2332774/202211/2332774-20221107235413644-847797422.png)

### 9.3 函数的参数

可以利用函数的参数实现函数重复不同的代码

#### 9.3.1 形参和实参

在`声明函数`时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为`形参`，而在`调用该函数`时，同样也需要传递相应的参数，这些参数被称为`实参`。


```js
function 函数名(形参1,形参2...) { //在声明函数小括号里是形参 (形式上的参数)

}

函数名(实参1,实参2...) //在函数调用的小括号里是实参(实际的参数)

函数的参数可以有也可以没有 个数不限

```

![](https://img2022.cnblogs.com/blog/2332774/202211/2332774-20221108002343363-1990898064.png)


`参数的作用`:在`函数内部`某些值不能固定，我们可以通过参数在`调用函数`时传递不同的值进去。

#### 9.3.2 函数形参和实参个数不匹配问题

![](https://img2022.cnblogs.com/blog/2332774/202211/2332774-20221108003536321-1935909135.png)

```js
function sum (num1,num2) {
console.log (num1 + num2);
)
sum ( 100,200) ; //形参和实参个数相等，输出正确结果
sum (100,400,500，700);//实参个数多于形参，只取到形参的个数
sum (200) ;//实参个数少于形参，多的形参定义为undefined，结果为NaN

```

`注意`:在JavaScript中，形参的默认值是`undefined`.

**总结**
- 函数可以带参数也可以不带参数
- 声明函数的时候，函数名括号里面的是形参，形参的默认值为undefined调用函数的时候，函数名括号里面的是实参
- 多个参数中间用逗号分隔
- 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配

### 9.4 函数的返回值

#### 9.4.1 return语句

有的时候，我们会希望函数将值返回给调用者，此时通过使用return语句就可以实现。

```js
function 函数名(){
    return 需要返回的结果
}
函数名()
```

- 我们函数只是实现某种功能，最终的结果需要返回给函数的调用者 函数名() 通过return实现的
- 只要函数遇到return 就把后面的结果返回给函数的调用者 函数名() = return 后面的接过

```js
function getResult(){
    return 'getResult'
}

console.log(getResult());//getResult

function cook(arg){
    return arg;
}
console.log(cook('蔬菜'));///蔬菜
```

```js
//利用函数 求两个数的最大值
function getMax(n1, n2) {
    // if (n1 > n2) { return n1 } else return n2
    return n1 > n2 ? n1 : n2
}
console.log(getMax(11,3));//11
```

#### 9.4.2 return终止函数

**return语句之后的代码不被执行。**

```js
function add (num1 , num2) {
//函数体
return num1 + num2 ;  // 注意: return后的代码不执行alert(·我不会被执行，因为前面有return);
var resNum = add(21,6);//调用函数，传入两个实参，并通过resNum接收函数返回值
alert (resNum); // 27
}
```

#### 9.4.3 return的返回值

**return只能返回一个值。**如果用逗号隔开多个值，以最后一个为准。

```js
function add2(num1, num2) {
    //函数体
    return num1, num2;
}
console.log(add2(23, 1)); // 1

//如果需要返回多个值，可以使用return一个数组等方法
function getResult(n1, n2) {
    return [n1 + n2, n1 * n2, n1 - n2, n1 / n2]
}
console.log(getResult(25, 62));//[ 87, 1550, -37, 0.4032258064516129 ]
```

#### 9.4.4 函数没有return返回undefined

- 如果函数有 return 则返回的是 return 后面的值
- 如果没有 return 则返回 undefiend

#### 9.4.5 break continue return的区别

- break :结束当前的循环体(如for、while )
- continue :跳出本次循环，继续执行下次循环（如for、while )
- return :不仅可以退出循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码。

### 9.5 arguments的使用

当我们不确定有多少个参数传递的时候，可以用`arguments`来获取。在JavaScript中,arguments实际上它是当前函数的一个`内置对象`。所有函数都内置了一个arguments对象，arguments对象中`存储了传递的所有实参`。

`arguments展示形式是一个伪数组`，因此可以进行遍历。伪数组具有以下特点∶
- 具有length属性
- 按索引方式储存数据
- 不具有数组的push , pop等方法

```js
//arguments参数的使用 只有函数才有arguments对象﹐而且是每个函数都内置好了这个arguments
function fn() {
    console.log(arguments);//里面存储了所有传递的实际参数
    console.log(arguments.length);//3
    console.log(arguments[1]);//2
    //可以按照数组的方式遍历arguments
    /* 
    1
    2
    3
    */
    for (let i = 0; i < arguments.length; i++) {
        console.log(arguments[i]);
    }
}
fn(1, 2, 3)//[Arguments] { '0': 1, '1': 2, '2': 3 }

//伪数组
/* 
1.具有数组的长度
2.按照索引的方式来处理
3.它没有正真数组的一些方法 pop() push()
*/
```

### 9.6 使用函数的案例

```js
//利用函数的arguments参数求任意个数的最大值
function getMaxarg() {
    let max = arguments[0]
    for (let i = 0; i < arguments.length; i++) {
        if (arguments[i] > max) {
            max = arguments[i]
        }
    }
    return max
}
console.log(getMaxarg(1, 2, 5, 36, 45, 12));//45
console.log(getMaxarg(1, 32, 35, 346, 45, 12));//346
console.log(getMaxarg(1, 2, 35, 36, 545, 142));//545
```

```js
//利用函数翻转任意数组reverse翻转
function reverse(arr) {
    let newArr = [];
    for (let i = arr.length - 1; i >= 0; i--) {
        newArr[newArr.length] = arr[i];
    }
    return newArr;
}
let arr1 = reverse([1, 3, 4, 6, 9]);//[ 9, 6, 4, 3, 1 ]
console.log(arr1);
```

```js
//利用函数冒泡排序sort排序
function sort(arr) {
    for (var i = 0; i < arr.length - 1; i++) {
        for (var j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                var temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}
let arr2 = sort([1, 4, 2, 9]);
console.log(arr2);//[ 1, 2, 4, 9 
```

```js
//利用函数判断闰年
function isLeapYear(year) {
    //如果闰年返回true否则返回false
    let flag = false
    if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
        flag = true
    }
    return flag
}
console.log(isLeapYear(2000));//true
```

```js
/* 
函数可以调用另外一个函数
因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况。
*/
function fn1() {
    console.log('fn1调用了');
    fn2()//在fn1函数调研函数fn2
}
function fn2() {
    console.log('fn2调用了');
}
fn1()
/* 
fn1调用了
fn2调用了
*/
function backDay(year) {
    let result = isLeapYear(year)
    return result ? '这一年是闰年2月有29天' : '这一年是平年2月有28天'
}
console.log(backDay(2036));//这一年是闰年2月有29天
```

### 9.7 函数的两种声明方式

- 利用函数关键字自定义函数(命名函数)
```js
function fn(){

}
fn()
```

- 函数表达式(匿名函数)
```js
let VariableName = function(){
    console.log('函数表达式方式')
}
//VariableName是变量名不是函数名
//函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值而函数表达式里面存的是函数
//函数表达式也可以进行传递擦参数
let num = 10 //类似
```

## 10 作用域

- 能够说出JavaScript的两种作用域
- 能够区分全局变量和局部变量
- 能够说出如何在作用域链中查找变量的值

### 10.1 作用域的概念

#### 10.1.1 作用域概述

通常来说，一段程序代码中所用到的名字并不总是`有效`和`可用`的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用**提高了程序逻辑的局部性**，**增强了程序的可靠性**，**减少了名字冲突**。

#### 10.1.2 作用域分类

- 全局作用域：整个script标签或者是一个单独的js文件
- 局部作用域：在函数内部就是局部作用域，只在函数内部起效果和作用

### 10.2 变量的作用域

#### 10.2.1 变量的作用域分类

在JavaScript中，根据作用域的不同，变量可以分为两种:

- 全局变量：在全局作用域下的变量
**如果在函数内部，没有声明直接赋值的变量也属于全局变量。**
- 局部变量：在局部作用域下的变量，在函数内部的变量就是局部变量。
**函数的形参也可以看做是局部变量**

**从执行效率来看全局变量和局部变量来考虑**
- 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源。
- 局部变量当我们程序执行完毕就会销毁

#### 10.2.2 全局变量

在全局作用域下声明的变量叫做全局变量(在函数外部定义的变量)。

- 全局变量在代码的任何位置都可以使用
- 在全局作用域下var声明的变量是全局变量
- 特殊情况下，在函数内不使用var声明的变量也是全局变量(不建议使用)

#### 10.2.3 局部变量

在局部作用域下声明的变量叫做局部变量(在函数内部定义的变量)

- 局部变量只能在该函数内部使用
- 在函数内部var声明的变量是局部变量
- 函数的形参实际上就是局部变量

#### 10.2.4 全局变量和局部变量的区别
- 全局变量:在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存。
- 局部变量:只在函数内部使用，当其所在的代码块被执行时，会被初始化;当代码块运行结束后，就会被销毁，因此更节省内存空间。

javaScript现阶段没有块级作用域(ES5)，ES6新增的块级作用域。

### 10.3 作用域链

**只要是代码就有作用域**

- 写在函数内部就是局部作用域
- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。
- 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。

## 11 预解析

- 能够知道解析器运行JS分为哪两步
- 能够说出变量提升的步骤和运行过程
- 能够说出函数提升的步骤和运行过程

**JavaScript代码是由浏览器中的JavaScript解析器来执行的。**

> JavaScript解析器在运行JavaScript代码的时候分为两步︰**预解析**和**代码执行**。

1. 预解析：js会把js里所有的变量与函数声明定义提升到当前作用域的最前面

2. 预解析分为：变量预解析（变量提升） 和 函数预解析（函数提升）

- 变量提升： 就是把所有变量声明提升到当前作用域的最前面 **不提升赋值操作**
-  函数提升： 就是把所有函数声明提升到当前作用域最前面 **不调用函数**

3.  代码执行： 按照代码书写的顺序从上往下执行

```js
var num = 10;
fun1(); // undefined
function fun() {
  console.log(num);
  var num = 20;
}
// 相当于执行以下代码

var num;
function fun() {
  var num;
  console.log(num);
  num = 20;
}
num = 10;
fun();

// ------

var num = 10;
function fn() {
  console.log(num);
  var num = 20;
  console.log(num);
}
fn(); // undefined 20
// 相当于以下代码

var num;
function fn() {
  var num;
  console.log(num);
  num = 20;
  console.log(num);
}
num = 10;
fn();

// ------

var a = 18;
f1();

function fun() {
  var b = 9;
  console.log(a);
  console.log(b);
  var a = "123";
}
// 相当于以下代码
var a;
function f1() {
  var b;
  var a;
  b = 9;
  console.log(a);
  console.log(b);
  a = "123";
}
a = 18;
f1(); // undefined 9

// ------

f1();
console.log(c);
console.log(b);
console.log(a);
function f1() {
  var a = b = c = 9;
  console.log(a);
  console.log(b);
  console.log(c);
}
// 相当于以下代码
function f1() {
  var a = b = c = 9;
  // 相当于 var a = 9; b = 9; c = 9;  b和c直接赋值，没有声明 当 全局变量看
  // 集体声明 var a = 9,b = 9,c =9 ;
  console.log(a);//9
  console.log(b);//9
  console.log(c);//9
}
f1();
console.log(c);//9
console.log(b);//9
console.log(a);//undefined
```



