# JavaScript 基础语法

> 学习地址：https://www.bilibili.com/video/BV1Sy4y1C7ha

## 1 初识 JavaScript

### 1.1 JavaScript 历史

- 布兰登·艾奇 Brendan Eich 1961
- 1995 年完成设计
- LiveScript --- JavaScript

### 1.2 JavaScript 是什么

- 世界上最流行的语言之一， 是一种运行在客户端的脚本语。
- 脚本语言：不与要编译，运行过程中由 js 解释器逐行来进行解释并执行。
- 基于 Node.js 技术进行服务器端编程。

### 1.3 JavaScript 的作用

- 表单动态验证
- 网页特效
- 表单动态验证
- 服务端开发 Node.js
- 表桌面程序 Electron
- App Cordova
- 控制硬件-物联网 Ruff
- 游戏开发 cocos3d-js

### 1.4 HTML/CSS/JS 的关系

- html 决定网页结构和内容--看到什么
- css 决定网页呈现给用户的模样--好不好看
- 实现业务逻辑与页面控制--决定功能

### 1.5 浏览器执行 JS 简介

**浏览器分成两部分 渲染引擎与 JS 引擎**

- 渲染引擎：用来解析 HTML 与 CSS，俗称内核，例如 chrome-->blink
- JS 引擎：JS 解释器，用来读取网页中的 JavaScript 代码，对其处理后运行，例如 chrome-->V8

**浏览器本身并不会执行 JIS 代码，而是通过内置 JavaScript 引擎(解释器)来执行 JS 代码。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。**

### 1.6 JS 组成

**JS 基础**

- ECMAScript : Javascript 语法

#### 1.6.1 ECMAScript

- ECMAScript 是由 ECMA 国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。
- ECMAScript : ECMAScript 规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准。
- 更多参看 MDN: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JlavaScript technologies_overview

**JSApi**

- DOM : 页面文档对象模型

#### 1.6.2 DOM——文档对象模型

- 文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)。

- BOM : 浏览器对象模型

#### 1.6.3 BOM——浏览器对象模型

- BOM(Browser Object Model，简称 BOM)是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。

### 1.7 JS 初体验

**JS 有 3 种书写位置，分别为行内、内嵌和外部**。

#### 1.7.1 行内式 JS

- <input tyre="button" value="点我试试" onclick="alert (' Hello world')" />
- 可以将单行或少量 JS 代码写在 HTML 标签的事件属性中(以 on 开头的属性），如: onclick
- 注意单双引号的使用:在 HTML 中我们推荐使用双引号,JS 中我们推荐使用单引号
- 可读性差，在 html 中编写 JS 大星代码时，不方便阅读;
- 引号易错，引号多层嵌套匹配时，非常容易弄混;
- 特殊情况下使用

#### 1.7.2 内嵌式 JS

- <script>alert ( "Hello world~! " ) ;</script>

- 可以将多行 JS 代码写到<script>标签中

- 内嵌 JS 是学习时常用的方式

#### 1.7.3 外部 JS 文件

- <script src="my.js"></script>

- 利于 HTML 页面代码结构化，把大段 JS 代码独立到 HTML 页面之外，既美观，也方便文件级别的复用

- 引用外部 JS 文件的 script 标签中间不可以写代码

- 适合于 JS 代码量比较大的情况

## 2 JavaScript 注释

- 1.单行注释 ctrl + /

- 2.多行注释 shift + alt + a

- 3.vscode 修改-首选项-键盘快捷键

## 3 JavaScript 输入输出语句

- 为了方便信息的输入输出，JS 中提供了一些输入输出语句，其常用的语句如下 ∶
- 方法 说明 归属
- alert(msg) 浏览器弹出警示框 浏览器
- console.log(msg) 浏览器控制台打印输出信息 浏览器
- prompt(info) 浏览器弹出输入框，用户可以输入 浏览器

## 4 变量

### 4.1 变量概述

#### 4.1.1 什么是变量

- 用于存放数据的容器，我们通过变量名获取数据，甚至数据可以修改。

#### 4.1.2 变量在内存中的存储

- 本质：变量是程序在内存中申请的一块用来存放数据的空间

### 4.2 变量的使用

- 声明变量
- 赋值

#### 4.2.1 声明变量

```javascript
var age;
```

- var 是一个 JS 关键字，用来声明变量(variable 变量的意思)。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管
- age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间

#### 4.2.2 赋值

```js
age = 10;
```

- =用来把右边的值赋给左边的变量空间中 此处代表赋值的意思
- 变量值是程序员保存到变量空间里的值

### 4.3 变量的初始化

```js
var age = 18;
```

- 声明一个变量并赋值，我们称之为变量的初始化。

### 4.4 变量语法扩展

#### 4.4.1 更新变量

- —个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。

#### 4.4.2 声明多个变量

- 同时声明多个变量时，只需要写一个 var，多个变量名之间使用英文逗号隔开。

```js
var age = 18,
  gz = 3000,
  address = "wuhan";
```

#### 4.4.3 声明变量的特殊情况

- 只声明不赋值---undefined
- 不声明不赋值---error
- 不声明直接赋值--value

```javascript
// 只声明不赋值
var sex;
console.log(sex); //undefined

//不声明不赋值
console.log(tel); //error

//不声明直接赋值
qq = 1000;
console.log(); //1000
```

### 4.5 变量命名规范

- 由字母(A-Za-z)、数字(O-9)、下划线(\_)、美元符号($)组成，如: usrAge, num01,name 严格区分大小写。var app;和 var App;是两个变量
- 不能以数字开头。18age 是错误的
- 不能是关键字、保留字。例如: var、for、while
- 变量名必须有意义。MMD BBDnl→age
- 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName 推荐翻译网站:有道爱词霸

### 4.6 小结

- 为什么需要变量?---因为我们一些数据需要保存，所以需要变量
- 变量是什么?---变量就是一个容器，用来存放数据的。方便我们以后使用里面的数据
- 变量的本质是什么?---变量是内存里的一块空间，用来存储数据。
- 变量怎么使用的?---我们使用变量的时候，一定要声明变量，然后赋值，声明变量本质是去内存申请空间。
- 什么是变量的初始化?---声明变量并赋值我们称之为变量的初始化
- 变量命名规范有哪些?交换 2 个变量值的思路?---变量名尽量要规范,见名知意—驼峰命名法，区分哪些变量名不合法

## 5 数据类型

### 5.1 数据类型的简介

#### 5.1.1 为什么需要

- 在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。

#### 5.1.2 变量的数据类型

- 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。
- 在代码运行时，变量的数据类型是由 JS 引擎根据=右边变量值的数据类型来判断的，运行完毕之后，变量就确定了数据类型。
- JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型:

#### 5.1.3 数据类型的分类

**JS 把数据类型分为两类 ∶**

- 简单数据类型( Number, string,Boolean , Undefined,Nul1)

- 复杂数据类型（ object)

### 5.2 简单数据类型

#### 5.2.1 简单数据类型（基本数据类型）

简单数据类型 说明 默认值
Number 数字型，包含整型值和浮点型值，如 21、0.21 0
Boolean 布尔值类型，如 true . false，等价于 1 和 0 alse
String 字符串类型，如"张三”注意咱们 js 里面，字符串都带引号 ""
Undefined var a;声明了变量 a 但是没有给值，此时 a = undefined undefined
Null var a = null;声明了变量 a 为空值 null

#### 5.2.2 数字型 Number

- JavaScript 数字类型既可以用来保存整数值，也可以保存小数(浮点数）。

```js
var age = 21;
var Age = 21.3;
```

##### 5.2.2.1 数字型进制

- 最常见的进制有二进制、八进制、十进制、十六进制。

##### 5.2.2.2 数字型范围

- 最大值 1.7976931348623157e+308
- 最小值 5e-324

##### 5.2.2.3 数字型的三个特殊值

- lnfinity ,代表无穷大，大于任何数值
- -lnfinity ，代表无穷小，小于任何数值
- NaN ,Not a number ，代表一个非数值

##### 5.2.2.4 isNaN()

- 用来判断一个变量是否为非数字的类型，返回 true 或者 false
- isNaN(）这个方法用来判断非数字――并且返回一个值 如果是数字返回的是 false 如果不是数字返回的是 true

#### 5.2.3 字符串型 string

- 字符串型可以是引号中的任意文本，其语法为双引号""和单引号''

```js
var strMsg = "我爱北京天安门~"; //使用双引号表示字符串
var strMsg2 = "我爱吃猪蹄~"; //使用单引号表示字符串
//常见错误
var strMsg3 = 我爱大时子; //报错，没使用引号，会被认为是js代码，但js没有这些语法
```

- 因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。

##### 5.2.3.1 字符串引号嵌套

- JS 可以用单引号嵌套双引号，或者用双引号嵌套单引号(外双内单，外单内双)

```js
var strMsg ='我是"高帅富"程序猿'; //可以用'包含""
var strMsg2="我是'高帅富'程序猿";//也可以用""包含”
//常见错误
var badQuotes = 'What on earth?"; //报错，不能单双引号搭配
```

##### 5.2.3.2 字符串转义符

- 类似 HTML 里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。

- 转义符都是\开头的，常用的转义符及其说明如下 ∶

| 转义符 | 解释说明                     |
| ------ | ---------------------------- |
| \n     | 换行符， n 时 newline 的意思 |
| \\     | 斜杠\                        |
| \'     | ' 单引号                     |
| \"     | " 双引号                     |
| \t     | tab 缩进                     |
| \b     | 空格， b 时 blank 的意思     |

##### 5.2.3.3 字符串长度

- 字符串是由若千字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。

```js
var strMsg = "我是帅气多金的程序猿!";
alert(strMsg.length); //显示 11
```

##### 5.2.3.4 字符串拼接

- 多个字符串之间可以使用＋进行拼接，其拼接方式为字符串＋任何类型=拼接之后的新字符串
- 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串

```js
//1.1字符串"相加"
alert ( 'hello' + '' + 'world ' ) ; // hello world //1.2数值字符串"相加”
alert ( '100'+ '100') ; l 100100l l 1.3数值字符串＋数值
alert( '11. +12);
//12
```

- +号总结口诀：数值相加，字符相连

##### 5.2.3.5 字符串拼接加强

```js
console.log ( 'pink老师+ 18') ;
//只要有字符就会相连
var age = 18;
//console.log ( 'pink老师age岁啦');
//这样不行哦
console.log ('pink老师'+ age') ;
//pink老师18
console.log ( 'pink老师' + age + '岁啦');
//pink老师18岁啦
```

- 我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值
- 变呈是不能添加引号的，因为加|号的变量会变成字符串
- 加果变量两侧都有字符串拼接，口诀“引引加功”，删掉数字，变量写加中间

#### 5.2.4 布尔型 Boolean

- 布尔类型有两个值: true 和 false ，其中 true 表示真(对），而 false 表示假(错)。
- 布尔型和数字型相加的时候，true 的值为 1 ,false 的值为 0。

```js
console.log(true + 1); // 2
console.log(false + 1); // 1
```

#### 5.2.5 Undefined 和 Null

- 一个声明后没有被赋值的变量会有一个默认值 undefined(如果进行相连或者相加时，注意结果)

```js
var variable;
console.log(variable); // undefined
console.log("你好" + variable); //你好undefined
console.log(11 + variable); // NaN
console.log(true + variable); // lNaN
```

- 一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究 null)

```js
var vari = null;
console.log ( "你好' + vari) ; //你好null
console. log ( 11 + vari) ;// 11
console.log (true + vari) ;// 1

```

### 5.3 获取检测变量的数据类型

#### 5.3.1 获取检测变量的数据类型

- typeof 可用来获取检测变量的数据类型

```js
var num211 = 10;
console.log(typeof num211); //number
var str211 = "test";
console.log(typeof str211); //string
var flag211 = true;
console.log(typeof flag211); //boolean
var vari211 = undefined;
console.log(typeof vari211); //undefined
var timer211 = null;
console.log(typeof timer211); //object
```

#### 5.3.2 字面量

- 字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。
  - 数字字面量:8,9,10
  - 字符串字面量:黑马程序员',"大前端"
  - 布尔字面量: true , false

### 5.4 数据类型转换

#### 5.4.1 什么是数据类型转换

- 使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗染说，就是把一种数据类型的变量转换成另外一种数据类型。
- 我们通常会实现 3 种方式的转换 ∶
  - 转换为字符串类型
  - 转换为数字型
  - 转换为布尔型

#### 5.4.2 转换为字符串

| 方式            | 说明                         | 案例                               |
| --------------- | ---------------------------- | ---------------------------------- |
| toString()      | 转成字符串                   | var num=1; alert(num.toString())   |
| String 强制转换 | 转成字符串                   | var num=1; alert(num.String())     |
| 加号拼接字符串  | 和字符串拼接的结果都是字符串 | var num=1; alert(num+'我是字符串') |

- oString0 和 String0 使用方式不一样。
- 三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一种方式也称之为隐式转换。

#### 5.4.3 转换为数字型

| 方式                   | 说明                           | 案例                |
| ---------------------- | ------------------------------ | ------------------- |
| parselnt(string)函数   | 将 string 类型转成整数数值型   | parselnt("78')      |
| parseFloat(string)函数 | 将 string 类型转成浮点数数值型 | parseFloat('78.21') |
| Number()强制转换函数   | 将 string 类型转换为数值型     | Number(12')         |
| js 隐式转换( - \* l )  | 利用算术运算隐式转换为数值型   | '12' -0             |

#### 5.4.4 转换为布尔型

| 方式             | 说明                 | 案例           |
| ---------------- | -------------------- | -------------- |
| Boolean 函数函数 | 将其它类型转成布尔型 | Bolean('true') |

- 代表空、否定的值会被转换为 false ，如"、0、NaN、 null、undefined
- 其余值会被转换为 true

### 5.5 拓展阅读

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005725938-1542049222.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005753544-1863611358.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005823680-546571103.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005853466-1779377836.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719005915959-392837781.png)

![](https://img2022.cnblogs.com/blog/2332774/202207/2332774-20220719010005777-45957242.png)

## 6 运算符

- 能够使用常用运算符
- 能够说出前置递增和后置递增的区别
- 能够说出运算符的优先级

### 6.1 运算符

- 运算符( operator )也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。
- JavaScript 中常用的运算符有 ∶
  - 算数运算符
  - 递增和递减运算符
  - 比较运算符
  - 逻辑运算符
  - 赋值运算符

### 6.2 算数运算符

#### 6.2.1 算数运算符概述

- 概念:算术运算使用的符号，用于执行两个变量或值的算术运算。

| 运算符 | 说明 | 案例       |
| ------ | ---- | ---------- |
| +      | 加   | 10+20=30   |
| -      | 减   | 10-20=-10  |
| \*     | 乘   | 10\*20=200 |
| /      | 除   | 10/20=0.5  |
| %      | 取模 | 9%2=1      |

#### 6.2.2 浮点数的精度问题

- 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。

```
var result = 0.1 + 0.2;//结果不是0.3，而是:0.30000000000000004
console.log (0.07 * 100);//结果不是7，而是∶7.000000000000001
```

- 所以 ∶ 不要直接判断两个浮点数是否相等!

#### 6.2.3 注意

- 它的余数是 0 就说明这个数能被整除，这就是%取余运算符的主要用途
- 注意算术运算符优先级的，先乘除，后加减，有小括号先算小括号里面的

#### 6.2.4 表达式和返回值

- 表达式 ∶ 是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合
- 简单理解︰是由数字、运算符、变量等组成的式子

### 6.3 递增和递减运算符

#### 6.3.1 递增和递减运算符概述

- 如果需要反复给数字变量添加或减去 1，可以使用递增(++)和递减(--)运算符来完成。
- 在 JavaScript 中，递增（++)和递减(-- )既可以放在变量前面，也可以放在变量后面。
- 放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。

注意：递增和递减运算符必须和变量配合使用

#### 6.3.2 递增运算符

##### 6.3.2.1 前置递增运算符

- ++num 前置递增，就是自加 1，类似于 num = num + 1，但是++num 写起来更简单。
- 先自加后返回

##### 6.3.2.2 后置递增运算符

- num++后置递增，就是自加 1，类似于 num = num +1，但是 num++写起来更简单。
- 先返回原值，后自加

前置自增和后置自增如果单独使用效果是一样的

##### 6.3.2.3 总结

- 前置递增和后置递增运算符可以简化代码的编写，让变量的值+1 比以前写法更简单
- 单独使用时，运行结果相同
- 与其他代码联用时，执行结果会不同
- 后置:先原值运算，后自加(先人后己)
- 前置:先自加，后运算(先已后人)
- 开发时，大多使用后置递增/减，并且代码独占一行，例如:num++;或者 num--;

### 6.4 比较运算符

#### 6.4.1 比较运算符概述

概念︰比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值( true / false )作为比较运算的结果。

| 运算符名称 | 说明                      |
| ---------- | ------------------------- |
| <          | 小于号                    |
| >          | 大于号                    |
| >=         | 大于等于号                |
| <=         | 小于等于号                |
| ==         | 判等号（会转型）          |
| !=         | 不等号                    |
| === !==    | 全等 要求值和数据类型一致 |

#### 6.4.2 总结

| 符号 | 作用 | 用法                                     |
| ---- | ---- | ---------------------------------------- |
| =    | 赋值 | 把右边给左边                             |
| ==   | 判断 | 判断两边值是否相等（注意此时有隐式转换） |
| ===  | 全等 | 判断两边的值和数据类型是否完全相同       |

### 6.5 逻辑运算符

#### 6.5.1 逻辑运算符概述

概念 ∶ 逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断

| 逻辑运算符 | 说明           | 案例            |
| ---------- | -------------- | --------------- |
| &&         | 逻辑与=>与 and | true && false   |
| \|\|       | 逻辑或=>或 or  | true \|\| false |
| !          | 逻辑非=>非 not | !true           |

#### 6.5.2 逻辑与&&

两边都是 true 才返回 true，否则返回 false

#### 6.5.3 逻辑或 ||

两边都为 false 才返回 false，否则都为 true

#### 6.5.4 逻辑非 ！

逻辑非(!)也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false

#### 6.5.5 短路运算（逻辑中断）

- 短路运算的原理︰当有多个表达式(值)时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值
- 1.逻辑与
  - 语法 ∶ 表达式 1&&表达式 2
  - 如果第一个表达式的值为真，则返回表达式 2 如果第一个表达式的值为假，则返回表达式 1
- 逻辑或
  - 语法:表达式 1||表达式 2
  - 如果第一个表达式的值为真，则返回表达式 1 如果第一个表达式的值为假，则返回表达式 2

### 6.6 赋值运算符

**概念：用来把数据赋值给变量的运算符**
| 赋值运算符 | 说明 | 案例 |
| ---------- | -------------------- | ------------------- |
| = | 直接赋值 | var user='xx' |
| += -= | 加、减一个数后再赋值 | var age =10 ;age+=5 |
| _= /= %= | 乘、除、取模后再赋值 | var age = 2; age_=5 |

### 6.7 运算符优先级

| 优先级 | 运算符     | 顺序             |
| ------ | ---------- | ---------------- |
| 1      | 小括号     | ()               |
| 2      | 一元运算符 | ++ -- ！         |
| 3      | 算数运算符 | 先 \* / % 后 + - |
| 4      | 关系运算符 | > >= < <=        |
| 5      | 相等运算符 | == != === !==    |
| 6      | 逻辑运算符 | 先&&后\|\|       |
| 7      | 赋值运算符 | =                |
| 8      | 逗号运算符 | ,                |

- 一元运算符里面的逻辑非优先级很高
- 逻辑与比逻辑或优先级高

## 7 流程控制

### 7.1 流程控制概述

- 在一个程序执行的过程中,各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码
  的执行顺序来实现我们要完成的功能。
- 简单理解:流程控制就是来控制我们的代码按照什么结构顺序来执行
- 流程控制主要有三种结构,分别是顺序结构、分支结构和循环结构,这三种结构代表三种代码执行的顺序。

### 7.2 顺序流程控制

顺序结构是程序中最简单、最基本的流程控制 ,它没有特定的语法结构,程序会按照代码的先后顺序,依次执行,
程序中大多数的代码都是这样执行的。

### 7.3 分支流程控制

#### 7.3.1 分支结构

由上到下执行代码的过程中,根据不同的条件,执行不同的路径代码(执行代码多选一的过程) , 从而得到不同的结果

JS 语言提供了两种分支结构语句

- if 语句
- switch 语句

#### 7.3.2 if 分支语句

##### 7.3.2.1 语法结构

```js
//条件成立执行代码 否则什么也不做
if (条件表达式) {
  //条件成立执行的代码语句
}
```

语句可以理解为一个行为 ,循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下 ,会分
割成一个一个的语句。

##### 7.3.2.2 执行流程

![](https://img2022.cnblogs.com/blog/2332774/202204/2332774-20220423231647212-2097883354.png)

#### 7.3.3 if else 语句（双分支语句）

##### 7.3.3.1 语法结构

```
//条件成立 执行if里面代码 否则执行else里面的代码
if(条件表达式){
	//[如果]条件成立执行的代码
} else {
	[否则]执行的代码
}
```

##### 7.3.3.2 执行思路

![](https://img2022.cnblogs.com/blog/2332774/202204/2332774-20220423232729748-1658763727.png)

#### 7.3.4 if else if（ 多分支语句）

##### 7.3.4.1 语法结构

```
if(条件一){
    //语句1
} else if(条件二) {
    //语句二
} else {
    //最后的语句
}
```

##### 7.3.4.2 执行流程

![](https://img2022.cnblogs.com/blog/2332774/202204/2332774-20220425155052449-370452807.png)

- 如果条件表达式 1 满足就执行语句 1 执行完毕后，退出整个 if 分支语句
- 如果条件表达式 1 不满足，则判断条件表达式 2 满足的话， 执行语句 2 以此类推
- 如果上面的所有条件表达式都不成立，则执行 else 里面的语句

##### 7.3.4.3 注意

- 多分支还是多选一 最后只有一个语句执行
- else if 里面的条件理论上是可以任意多个的
- else if 中间有一个空格

#### 7.3.5 三元表达式

- 三元表达式也能做一些简单的条件选择。
- 有三元运算符组成的式子称为三元表达式

##### 7.3.5.1 语法结构

```
条件表达式 ? 表达式1 :表达式2
```

- 如果条件表达式结果为真则返回表达式 1 的值如果条件表达式结果为假则返回表达式 2 的值

#### 7.3.6 switch 语句

##### 7.3.6.1 语法结构

- switch 语句也是多分支语句,它用于基于不同的条件来执行不同的代码。
- 当要针对变量设置-系列的特定值的选项时,就可以使用 switch。

```js
switch (key) {
  case value:
    break;

  default:
    break;
}
switch (表达式) {
  case value1:
    //表达式等于value1时要执行的代码
    break;
  case value2:
    //表达式等于value2时要执行的代码
    break;
  default:
  //表达式不等于任何一个value时要执行的代码
}
```

##### 7.3.6.2 执行思路

- 利用我们的表达式的值和 case 后面的选项值相匹配
- 如果匹配上就执行该 case 里面的语句
- 如果 都没有匹配上，那么执行 default 里面的语句

##### 7.3.6.3 注意事项

- 表达式需要写成变量
- key 和 value 相匹配的时候是全等 必须数据与类型一致
- break 如果不设置 break 则不会退出 break 会继续执行下一个 case

#### 7.3.7 switcn 与 if else if 区别

- 一般情况下,它们两个语句可以相互替换
- switch..case 语句通常处理 case 为比较确定值的情况，而...e..语句更加灵活,常用于范围判断(大于、
  等于某个范围)
- switch 语句进行条件判断后直接执行到程序的条件语句,效率更高。i 而..else 语句有几种条件,就得判断多少次。
- 当分支比较少时, if.. else 语句的执行效率比 switch 语句高。
- 当分支比较多时, switch 语句的执行效率比较高,而且结构更清晰。

### 7.4 循环流程控制

#### 7.4.1.循环

- 目的：可以重复执行某些代码

#### 7.4.2.js 中的循环

- for 循环
- while 循环
- do while 循环

#### 7.4.3 for 循环

- 在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。
- 由循环体及循环的终止条件组成的语句，被称之为循环语句。

##### 7.4.3.1 语法结构

for 循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下

```js
for (初始化变量; 条件表达式; 操作表达式) {
  //循环体
}
```

- 初始化变量：声明的一个普通变量，通常用于作为计数器使用
- 条件表达式：用来决定每一次循环是否继续执行 就是终止条件
- 操作表达式：是每次循环最后执行的代码 经常用于我们计数器变量进行更新（递增或者递减）

```js
for (let i = 0; i < 100; i++) {
  console.log("执行代码");
}
```

##### 7.4.3.2 执行过程

- 首先执行里面的计数器变量 var i = 1 但是这句话在 for 里面只执行一次 index
- 去 i <= 100 来判断是否满足条件，如果满足条件︰就去执行循环体,不满足条件退出循环
- 最后去执行 i++ i++是单独写的代码 递增 第一轮结束
- 接着去执行 i <= 100 如果满足条件 就去执行循环体 不满足条件退出循环 第二轮 以此类推

##### 7.4.3.3 断点调试

- 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，
- 然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行的显示错误，停下。
- 断点调试可以帮我们观察程序的运行过程
- 浏览器中按 F12--> sources -->找到需要调试的文件-->在程序的某一行设置断点 Watch:监视，
- 通过 watch 可以监视变量的值的变化，非常的常用。
- F11:程序单步执行，让程序一行一行的执行，这个时候，观察 watch 中变量的值的变化。
- 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决 bug 的能力。
- 初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。
- 今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。

##### 7.4.3.4 for 循环执行相同/不同代码

```js
for (let i = 0; i < 100; i++) {
  console.log("执行代码");
}
```

- for 循环可以重复执行不同的代码 因为有计数器变量 i 的存在，i 每次循环都会变化可以控制执行不同的代码

```js
for (let i = 0; i < 100; i++) {
  console.log("第" + i + "次执行");
}
```

- 根据 i 值的不同，做出对应不同的操作与处理
- for 循环重复执行某些操作

```js
let init = 0;
for (let i = 0; i <= 100; i++) {
  init += i;
}
console.log(init); //5050
```

##### 7.4.3.5 双层 for 循环

很多情况下，单层 for 循环并不能满足我们的需求，比如我们要打印一个 5 行 5 列的图形、打印一个倒直角三角形等，此时就可以通过循环嵌套来实现。

循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例妆在 for 循环语句中，可以再嵌套一个 for 循环，这样的 for 循环语句我们称之为双重 for 循环。

```js
//双重for循环 语法结构
for (外层初始化变量; 外层的条件表达式; 外层的操作表达式) {
  for (内层初始化变量; 内层的条件表达式; 内层的操作表达式) {
    //执行语句
  }
}
//可以把里的循环看作是外层循环的语句
//外层的循环执行一次，里面的循环执行全部
```

```js
for (let i = 0; i < 5; i++) {
  console.log("外层循环", i, "次😁");
  for (let j = 0; j < 5; j++) {
    console.log("内层循环", j, "次😋😎😍");
  }
}
let startStr = "";
//打印五行五列星星
for (let i = 0; i < 5; i++) {
  for (let j = 0; j < 5; j++) {
    startStr = startStr + "💕";
  }
  startStr = startStr + "\n";
}
console.log(startStr);

let startStr2 = "";
//打印五行五列星星
for (let i = 0; i < 5; i++) {
  for (let j = 0; j < 5 - i; j++) {
    startStr2 = startStr2 + "🎈";
  }
  startStr2 = startStr2 + "\n";
}
console.log(startStr2);

/* 九九乘法表
一共有9行，但是每行的个数不一样，因此需要用到双重for循环外层的 for循环控制行数i，循环9次，可以打印9行
内层的 for循环控制每行公式j
核心算法:每一行公式的个数正好和行数一致，j<= i;每行打印完毕，都需要重新换一行 */
let multiplication = "";
for (let i = 1; i <= 9; i++) {
  for (let j = 1; j <= i; j++) {
    // multiplication = multiplication + '🎗'
    multiplication += j + "x" + i + "=" + i * j + " ";
  }
  multiplication = multiplication + "\n";
}
console.log(multiplication);
```

##### 7.4.3.6 for 循环小结

- for 循环可以重复执行某些相同代码
- for 循环可以重复执行些许不同的代码，因为我们有计数器
- for 循环可以重复执行某些操作，比如算术运算符加法操作
- 随着需求增加，双重 for 循环可以做更多、更好看的效果
- 双重 for 循环,外层循环一次，内层 for 循环全部执行
- for 循环是循环条件和数字直接相关的循环
- 分析要比写代码更重要
- 一些核心算法想不到，但是要学会，分析它执行过程
- 举一反三，自己经常总结，做一些相似的案例

#### 7.4.4 while 循环

while 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环

##### 7.4.4.1 语法结构

while 语句的语法结构如下:

```js
while (条件表达式) {
  //循环体代码
}
```

执行思路 ∶

- 先执行条件表达式，如果结果为 true，则执行循环体代码;如果为 false，则退出循环，执行后面代码)
- 执行循环体代码
- 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为 true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束

##### 7.4.4.2 执行过程

执行思路 当条件表达式结果为 true 则执行循环体否则退出

```js
let whileNum = 1;
while (whileNum < 100) {
  console.log("how are you");
  whileNum++;
}
```

#### 7.4.5 do while 循环

do... while 语句其实是 while 语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，断则退出循环。

##### 7.4.5.1 语法结构

```js
do {
  //循环体
} while (条件表达式);
```

##### 7.4.5.2 执行过程

执行思路 跟 while 不同的地方在于 do while 先执行一次循环体 再判断条件
如果条件表达式结果为真 则继续执行代码 否则退出循环

```js
let doI = 1;
do {
  console.log("hello");
  doI++;
} while (doI <= 100);
```

#### 7.4.6 do 循环小结

- JS 中循环有 for . while、do while
- 三个循环很多情况下都可以相互替代使用
- 如果是用来计次数，跟数字相关的，三者使用基本相同，但是我们更喜欢用 for
- while 和 do...while 可以做更复杂的判断条件，比 for 循环灵活一些
- while 和 do...while 执行顺序不一样，while 先判断后执行，do...while 先执行一次，再判断执行
- while 和 do...while 执行次数不一样，do...while 至少会执行一次循环体，而 while 可能一次也不执行
- 实际工作中，我们更常用 for 循环语句，它写法更简洁直观，所以这个要重点学习

#### 7.4.7 continue break

##### 7.4.7.1 continue 关键字

continue 关键字用于立即跳出本次循环，继续下一次循环(本次循环体中 continue 之后的代码就会少执行一次）。

例如，吃 5 个包子，第 3 个有虫子，就扔掉第 3 个，继续吃第 4 个第 5 个包子，其代码实现如下:

```js
for (let i = 1; i <= 5; i++) {
  if (i === 3) {
    continue;
  }
  console.log("正在吃第" + i + "个");
}
/*
正在吃第1个
正在吃第2个
正在吃第4个
正在吃第5个
*/
```

##### 7.4.7.2 break 关键字

break 关键字用于立即跳出整个循环（循环结束)。

例如，吃 5 个包子，吃到第 3 个发现里面有半个虫子，其余的不吃了，其代码实现如下;

```js
for (let i = 1; i <= 5; i++) {
  if (i === 3) {
    break;
  }
  console.log("正在吃第" + i + "个包子");
}
/*
正在吃第1个
正在吃第2个
*/
```

### 7.5 JavaScript 命名规范以及语法格式

能够知道 JS 中命名规范规则

能够够书写规范的 JS 代码

- 标识符命名规范
  - 变量、函数的命名必须要有意义
  - 变量的名称一般用名词
  - 函数的名称一般用动词
- 操作符规范

```js
//操作符的左右两侧各保留一个空格
for (var i = 1; i <= 5; i++) {
  if (i == 3) {
    break;
    //直接退出整个for循环，跳到整个for循环下面的语句
  }
  console.log(我正在吃第· + i + "个包子呢");
}
```

- 单行注释规范

```js
for (var i = 1; i <= 5; i++){
  if (i == 3){
    break;
    //单行注释前面注意有个空格
  }
console.log("我正在吃第·+i + "个包子呢');
}
```

- 其他规范
  - 注意保留空格

## 8 数组

目标：

- 能知道为什么要有数组
- 能够创建数组
- 能够以获取数组中的元素
- 能够对数组进行遍历
- 能够给数组新增一个元素

### 8.1 数组的概念

- 问:之前学习的变量，只能存储一个值。如果我们想存储班级中所有学生的姓名，那么该如何存储呢?
- 答:可以使用数组(Array)。数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。

**什么是数组**∶ 数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。

```js
1 / 普通变量一次只能存储一个值;
var num = 10;
//数组一次可以存储多个值
var arr = [1, 2, 3, 4, 5];
```

### 8.2 创建数组

#### 8.2.1 数组的创建方式

JS 中创建数组有两种方式:

- 利用 new 创建数组
- 利用数组字面量创建数组

#### 8.2.2 利用 new 创建数组

```js
var 数组名 = new Array();
var arr = new Array(); //创建一个新的空数组
```

#### 8.2.3 利用数组字面量创建数组

```js
//1.数组字面量方式创建空的数组
var 数组名=[ ];
//2．使用数组字面量方式创建带初始值的数组
var 数组名=['小白'，"小黑','大黄"，'瑞奇'l;
```

- 数组的字面量是方括号[]
- 声明数组并赋值称为数组的初始化
- 这种字面量方式也是我们以后最多使用的方式

#### 8.2.4 数组元素类型

数组中可以存放`任意类型`的数据，例如字符串，数字，布尔值等。

### 8.3 获取数组元素

#### 8.3.1 数组的索引

`索引(下标`)∶ 用来访问数组元素的序号（数组下标从 О 开始）。

数组可以通过`索引`来访问、设置、修改对应的数组元素，我们可以通过“`数组名[索引`”的形式来获取数组中的元素。
心
这里的`访问`就是获取得到的意思

### 8.4 遍历数组

- 问 ∶ 数组中的每一项我们怎么取出来?
- 答:可以通过“数组名[索引引]”的方式一项项的取出来。

- 问:怎么把数组里面的元素全部取出来?
- 规律︰从代码中我们可以发现，从数组中取出每一个元素时，代码是重复的，有所不一样的是索引值在递增 答案就是`循环`

`遍历:`就是把数组中的每个元素从头到尾都访问一次(类似我们每天早上学生的点名）。

```js
//数组的遍历 就是把数组的元素从头到尾访问一遍
let arr2 = ["a", "b", "c"];
for (let i = 0; i < 3; i++) {
  // i 当作计数器索引来使用
  console.log(arr2[i]);
}
```

#### 8.4.1 数组的长度

- 数组的长度是元素的个数
- 数组的长度是动态检测数组元素的个数

```js
let arr2 = ["a", "b", "c"];
console.console.log(arr2.length); //3
```

#### 8.4.2 求数组的和、平均值、最大值

```js
//求数组的平均值与和
let arr3 = [2, 6, 1, 7, 4];
let sum3 = 0;
let average3 = 0;
for (let i = 0; i < arr3.length; i++) {
  sum3 += arr3[i];
}
console.log("arr3的和是：", sum3); //20
console.log("arr3的平均值是：", sum3 / arr3.length); //4
```

```js
//求数组中的最大值
/**
声明一个保存最大元素的变量max。
默认最大值可以取数组中的第一个元素。
遍历这个数组，把里面每个数组元素和max相比较。
如果这个数组元素大于max就把这个数组元素存到max里面，否则继续下一轮比较。
最后输出这个max。
 */
let arr4 = [2, 6, 1, 77, 52, 25, 7];
let max4 = arr4[0];
for (let i = 1; i < arr4.length; i++) {
  if (arr4[i] > max4) {
    max4 = arr4[i];
  }
}
console.log("arr4的最大值是：", max4); //77
```

#### 8.4.2 数组转换为分割字符串

```js
//数组转换为分割字符串 将数组转换为字符串并使用其它字符串分割
/* 
将数组['red', 'green', 'blue', 'pink']转换为字符串，并且用│或其他符号分割
1.需要一个新变量用于存放转换完的字符串 str。
2.遍历原来的数组，分别把里面数据取出来，加到字符串里面。
3.同时在后面多加一个分隔符
 */
let arr5 = ["red", "green", "blue", "pink"];
let str5 = "";
for (let i = 0; i < arr5.length; i++) {
  str5 += arr5[i] + "|"; //可以将 | 用变量代替，使用其它任何字符
}
console.log("分割字符串：", str5); //分割字符串： red|green|blue|pink|
```

### 8.5 数组中新增元素

#### 8.5.1 通过修改 length 长度新增数组元素

- 可以通过修改 length 长度来实现数组扩容的目的
- length 属性是可读写的

```js
let arr1017 = [24, 8, 6, 8];
console.log(arr1017.length);
arr1017.length = 5;
console.log(arr1017); //[ 24, 8, 6, 8, <1 empty item> ]
console.log(arr1017[4]); //undefined
```

#### 8.5.2 通过修改数组索引新增数组元素

- 可以通过修改数组索引的方式追加数组元素
- 不能直接给数组名赋值，否则会覆盖掉以前的数据

```js
//新增数组元素 修改索引号
//新增数组元素 修改索引号
let arr10172 = ["red", "green"];
arr10172[2] = "pionk";
console.log(arr10172); //[ 'red', 'green', 'pionk' ]
arr10172[1] = "blue";
console.log(arr10172); //[ 'red', 'blue', 'pionk' ] 替换原来的元素
arr10172 = "有点意思";
console.log(arr10172); //有点意思 不能直接给数组名赋值，否则会覆盖掉以前的数据
```

#### 8.5.3 循环追加数组

```js
//循环追加数组
/* 
使用循环来追加数组。声明一个空数组arr。
循环中的计数器i可以作为数组元素存入。
由于数组的索引号是从O开始的，因此计数器从О开始更合适，存入的数组元素要+1。
*/
let arr1023 = [];
for (let i = 0; i < 10; i++) {
  arr1023[i] = i;
}
console.log(arr1023);
// [0, 1, 2, 3, 4,5, 6, 7, 8, 9]
```

#### 8.5.4 筛选数组

```js
//筛选数组
let arr10232 = [2, 0, 6, 1, 77, 0, 52, 0, 25, 7];
/* 
声明一个新的数组用于存放新数据newArr 。
遍历原来的旧数组，找出大于等于10的元素。
依次追加给新数组newArr。
*/
let newArr10232 = [];
let j = 0;
for (let i = 0; i < arr10232.length; i++) {
  if (arr10232[i] >= 10) {
    // newArr10232.push(arr10232[i])
    //新数组从0开始依次递增
    newArr10232[j] = arr10232[i];
    j++;
    // newArr10232[newArr10232.length] = arr10232[i]
  }
}
console.log(newArr10232); //[ 77, 52, 25 ]
```

### 8.6 数组的使用操作

#### 8.6.1 数组删除指定元素

```js
/* 
需要一个新数组用于存放筛选之后的数据。
遍历原来的数组，把不是0的数据添加到新数组里面(此时要注意采用数组名+索引的格式接收数据)。
新数组里面的个数,用length不断累加。
*/
let newArr10233 = [];
for (let i = 0; i < arr10232.length; i++) {
  if (arr10232[i] != 0) {
    newArr10233[newArr10233.length] = arr10232[i];
  }
}
console.log(newArr10233); //[2,  6, 1, 77,52, 25, 7]
```

#### 8.6.2 翻转数组

- 要求:将数组['red" , 'green", 'blue' , 'pink , 'purple']的内容反过来存放。
- 输出:['purple' , "pink" , 'blue' , ' green', 'red']

```js
let arr10233 = ["red", "green", "blue", "black"];
let newArr10234 = [];

for (let i = arr10233.length - 1; i >= 0; i--) {
  newArr10234[newArr10234.length] = arr10233[i];
}
console.log(newArr10234); //[ 'black', 'blue', 'green', 'red' ]
```

#### 8.6.3 冒泡排序

`冒泡排序`∶ 是一种算法，把一系列的数据按照一定的顺序进行排列显示(从小到大或从大到小)。

摘要

- 冒泡排序是一种简单的排序算法。
- 它重复地走访过要排序的数列，一次比较两个元嘉 ↓ 如果他们的顺序措误就把他们交换过来。
- 走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
- 这个算法的名字由来是因为越小的元素会经由交换慢慢 ° 浮"到数列的顶端。

```js
let arr10235 = [5, 9, 6, 58, 14, 52, 41, 8];
for (let i = 0; i <= arr10235.length - 1; i++) {
  // 外层for循环管次数
  for (let j = 0; j <= arr10235.length - i - 1; j++) {
    // 内层的循环管每一趟交换的次数
    //内部交换2个变量的值 前一个和后面一个数组元素相比较
    // if (arr10235[j] < arr10235[j + 1])
    if (arr10235[j] > arr10235[j + 1]) {
      let temp = arr10235[j];
      arr10235[j] = arr10235[j + 1];
      arr10235[j + 1] = temp;
    }
  }
}
console.log(arr10235); //[5,  6,  8,  9,14, 41, 52, 58]
```

## 9 函数

`目标`

- 能够说出为什么需要函数
- 能够根据语法书写函数能够根据需求封装函数
- 能够说出形参和实参的传递过程
- 能够使用函数的返回值
- 能够使用 arguments 获取函数的参数

`目录`

- 函数的概念
- 函数的使用
- 函数的参数
- 函数的返回值
- arguments 的使用
- 函数案例
- 函数的两种声明方式

### 9.1 函数的概念

在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。

虽然 for 循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。

`函数`∶ 就是封装了一段`可被重复调用执行的代码块`。通过此代码块可以实现大量代码的重复使用。

```js
// 案例 求数组的累加和
// 1-100 10-50
let sum1111 = 0;
for (let i = 1; i <= 100; i++) {
  sum1111 += i;
}
console.log(sum1111); //5050

let sum1112 = 0;
for (let i = 10; i <= 50; i++) {
  sum1112 += i;
}
console.log(sum1112); //1230

//函数方法
function getSum(num1, num2) {
  let sum = 0;
  for (let i = num1; i <= num2; i++) {
    sum += i;
  }
  console.log(sum);
}
getSum(1, 100); //5050
getSum(10, 50); //1230
```

`目的`：让大量代码重复使用.

### 9.2 函数的使用

函数在使用时分为两步:`声明函数`和`调用函数`。

#### 9.2.1 声明函数

- function 是声明函数的关键字,必须小写
- 由于函数一般是为了实现某个功能才定义的，所以通常我们将函数名命名为动词，比如 getSum

```js
/* 
function 函数名 () {
    //函数体
}
 */
function sayHi() {
  console.log("hi~~~~");
}
```

#### 9.2.2 调用函数

- 调用的时候千万不要忘记添加小括号。
- 口诀:函数不调用，自己不执行。
  注意:声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。

```js
// 函数名()
sayHi();
```

#### 9.2.3 函数的封装

函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口

简单理解︰封装类似于将电脑配件整合组装到机箱中(类似快递打包)

![](https://img2022.cnblogs.com/blog/2332774/202211/2332774-20221107235413644-847797422.png)

### 9.3 函数的参数

可以利用函数的参数实现函数重复不同的代码

#### 9.3.1 形参和实参

在`声明函数`时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为`形参`，而在`调用该函数`时，同样也需要传递相应的参数，这些参数被称为`实参`。

```js
function 函数名(形参1,形参2...) { //在声明函数小括号里是形参 (形式上的参数)

}

函数名(实参1,实参2...) //在函数调用的小括号里是实参(实际的参数)

函数的参数可以有也可以没有 个数不限

```

![](https://img2022.cnblogs.com/blog/2332774/202211/2332774-20221108002343363-1990898064.png)

`参数的作用`:在`函数内部`某些值不能固定，我们可以通过参数在`调用函数`时传递不同的值进去。

#### 9.3.2 函数形参和实参个数不匹配问题

![](https://img2022.cnblogs.com/blog/2332774/202211/2332774-20221108003536321-1935909135.png)

```js
function sum (num1,num2) {
console.log (num1 + num2);
)
sum ( 100,200) ; //形参和实参个数相等，输出正确结果
sum (100,400,500，700);//实参个数多于形参，只取到形参的个数
sum (200) ;//实参个数少于形参，多的形参定义为undefined，结果为NaN

```

`注意`:在 JavaScript 中，形参的默认值是`undefined`.

**总结**

- 函数可以带参数也可以不带参数
- 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined 调用函数的时候，函数名括号里面的是实参
- 多个参数中间用逗号分隔
- 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配

### 9.4 函数的返回值

#### 9.4.1 return 语句

有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。

```js
function 函数名() {
  return 需要返回的结果;
}
函数名();
```

- 我们函数只是实现某种功能，最终的结果需要返回给函数的调用者 函数名() 通过 return 实现的
- 只要函数遇到 return 就把后面的结果返回给函数的调用者 函数名() = return 后面的接过

```js
function getResult() {
  return "getResult";
}

console.log(getResult()); //getResult

function cook(arg) {
  return arg;
}
console.log(cook("蔬菜")); ///蔬菜
```

```js
//利用函数 求两个数的最大值
function getMax(n1, n2) {
  // if (n1 > n2) { return n1 } else return n2
  return n1 > n2 ? n1 : n2;
}
console.log(getMax(11, 3)); //11
```

#### 9.4.2 return 终止函数

**return 语句之后的代码不被执行。**

```js
function add(num1, num2) {
  //函数体
  return num1 + num2; // 注意: return后的代码不执行alert(·我不会被执行，因为前面有return);
  var resNum = add(21, 6); //调用函数，传入两个实参，并通过resNum接收函数返回值
  alert(resNum); // 27
}
```

#### 9.4.3 return 的返回值

**return 只能返回一个值。**如果用逗号隔开多个值，以最后一个为准。

```js
function add2(num1, num2) {
  //函数体
  return num1, num2;
}
console.log(add2(23, 1)); // 1

//如果需要返回多个值，可以使用return一个数组等方法
function getResult(n1, n2) {
  return [n1 + n2, n1 * n2, n1 - n2, n1 / n2];
}
console.log(getResult(25, 62)); //[ 87, 1550, -37, 0.4032258064516129 ]
```

#### 9.4.4 函数没有 return 返回 undefined

- 如果函数有 return 则返回的是 return 后面的值
- 如果没有 return 则返回 undefiend

#### 9.4.5 break continue return 的区别

- break :结束当前的循环体(如 for、while )
- continue :跳出本次循环，继续执行下次循环（如 for、while )
- return :不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码。

### 9.5 arguments 的使用

当我们不确定有多少个参数传递的时候，可以用`arguments`来获取。在 JavaScript 中,arguments 实际上它是当前函数的一个`内置对象`。所有函数都内置了一个 arguments 对象，arguments 对象中`存储了传递的所有实参`。

`arguments展示形式是一个伪数组`，因此可以进行遍历。伪数组具有以下特点 ∶

- 具有 length 属性
- 按索引方式储存数据
- 不具有数组的 push , pop 等方法

```js
//arguments参数的使用 只有函数才有arguments对象﹐而且是每个函数都内置好了这个arguments
function fn() {
  console.log(arguments); //里面存储了所有传递的实际参数
  console.log(arguments.length); //3
  console.log(arguments[1]); //2
  //可以按照数组的方式遍历arguments
  /* 
    1
    2
    3
    */
  for (let i = 0; i < arguments.length; i++) {
    console.log(arguments[i]);
  }
}
fn(1, 2, 3); //[Arguments] { '0': 1, '1': 2, '2': 3 }

//伪数组
/* 
1.具有数组的长度
2.按照索引的方式来处理
3.它没有正真数组的一些方法 pop() push()
*/
```

### 9.6 使用函数的案例

```js
//利用函数的arguments参数求任意个数的最大值
function getMaxarg() {
  let max = arguments[0];
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] > max) {
      max = arguments[i];
    }
  }
  return max;
}
console.log(getMaxarg(1, 2, 5, 36, 45, 12)); //45
console.log(getMaxarg(1, 32, 35, 346, 45, 12)); //346
console.log(getMaxarg(1, 2, 35, 36, 545, 142)); //545
```

```js
//利用函数翻转任意数组reverse翻转
function reverse(arr) {
  let newArr = [];
  for (let i = arr.length - 1; i >= 0; i--) {
    newArr[newArr.length] = arr[i];
  }
  return newArr;
}
let arr1 = reverse([1, 3, 4, 6, 9]); //[ 9, 6, 4, 3, 1 ]
console.log(arr1);
```

```js
//利用函数冒泡排序sort排序
function sort(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    for (var j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        var temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
let arr2 = sort([1, 4, 2, 9]);
console.log(arr2); //[ 1, 2, 4, 9
```

```js
//利用函数判断闰年
function isLeapYear(year) {
  //如果闰年返回true否则返回false
  let flag = false;
  if ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) {
    flag = true;
  }
  return flag;
}
console.log(isLeapYear(2000)); //true
```

```js
/* 
函数可以调用另外一个函数
因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况。
*/
function fn1() {
  console.log("fn1调用了");
  fn2(); //在fn1函数调研函数fn2
}
function fn2() {
  console.log("fn2调用了");
}
fn1();
/* 
fn1调用了
fn2调用了
*/
function backDay(year) {
  let result = isLeapYear(year);
  return result ? "这一年是闰年2月有29天" : "这一年是平年2月有28天";
}
console.log(backDay(2036)); //这一年是闰年2月有29天
```

### 9.7 函数的两种声明方式

- 利用函数关键字自定义函数(命名函数)

```js
function fn() {}
fn();
```

- 函数表达式(匿名函数)

```js
let VariableName = function () {
  console.log("函数表达式方式");
};
//VariableName是变量名不是函数名
//函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值而函数表达式里面存的是函数
//函数表达式也可以进行传递擦参数
let num = 10; //类似
```

## 10 作用域

- 能够说出 JavaScript 的两种作用域
- 能够区分全局变量和局部变量
- 能够说出如何在作用域链中查找变量的值

### 10.1 作用域的概念

#### 10.1.1 作用域概述

通常来说，一段程序代码中所用到的名字并不总是`有效`和`可用`的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用**提高了程序逻辑的局部性**，**增强了程序的可靠性**，**减少了名字冲突**。

#### 10.1.2 作用域分类

- 全局作用域：整个 script 标签或者是一个单独的 js 文件
- 局部作用域：在函数内部就是局部作用域，只在函数内部起效果和作用

### 10.2 变量的作用域

#### 10.2.1 变量的作用域分类

在 JavaScript 中，根据作用域的不同，变量可以分为两种:

- 全局变量：在全局作用域下的变量
  **如果在函数内部，没有声明直接赋值的变量也属于全局变量。**
- 局部变量：在局部作用域下的变量，在函数内部的变量就是局部变量。
  **函数的形参也可以看做是局部变量**

**从执行效率来看全局变量和局部变量来考虑**

- 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源。
- 局部变量当我们程序执行完毕就会销毁

#### 10.2.2 全局变量

在全局作用域下声明的变量叫做全局变量(在函数外部定义的变量)。

- 全局变量在代码的任何位置都可以使用
- 在全局作用域下 var 声明的变量是全局变量
- 特殊情况下，在函数内不使用 var 声明的变量也是全局变量(不建议使用)

#### 10.2.3 局部变量

在局部作用域下声明的变量叫做局部变量(在函数内部定义的变量)

- 局部变量只能在该函数内部使用
- 在函数内部 var 声明的变量是局部变量
- 函数的形参实际上就是局部变量

#### 10.2.4 全局变量和局部变量的区别

- 全局变量:在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存。
- 局部变量:只在函数内部使用，当其所在的代码块被执行时，会被初始化;当代码块运行结束后，就会被销毁，因此更节省内存空间。

javaScript 现阶段没有块级作用域(ES5)，ES6 新增的块级作用域。

### 10.3 作用域链

**只要是代码就有作用域**

- 写在函数内部就是局部作用域
- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。
- 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。

## 11 预解析

- 能够知道解析器运行 JS 分为哪两步
- 能够说出变量提升的步骤和运行过程
- 能够说出函数提升的步骤和运行过程

**JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。**

> JavaScript 解析器在运行 JavaScript 代码的时候分为两步︰**预解析**和**代码执行**。

1. 预解析：js 会把 js 里所有的变量与函数声明定义提升到当前作用域的最前面

2. 预解析分为：变量预解析（变量提升） 和 函数预解析（函数提升）

- 变量提升： 就是把所有变量声明提升到当前作用域的最前面 **不提升赋值操作**
- 函数提升： 就是把所有函数声明提升到当前作用域最前面 **不调用函数**

3.  代码执行： 按照代码书写的顺序从上往下执行

```js
var num = 10;
fun1(); // undefined
function fun() {
  console.log(num);
  var num = 20;
}
// 相当于执行以下代码

var num;
function fun() {
  var num;
  console.log(num);
  num = 20;
}
num = 10;
fun();

// ------

var num = 10;
function fn() {
  console.log(num);
  var num = 20;
  console.log(num);
}
fn(); // undefined 20
// 相当于以下代码

var num;
function fn() {
  var num;
  console.log(num);
  num = 20;
  console.log(num);
}
num = 10;
fn();

// ------

var a = 18;
f1();

function fun() {
  var b = 9;
  console.log(a);
  console.log(b);
  var a = "123";
}
// 相当于以下代码
var a;
function f1() {
  var b;
  var a;
  b = 9;
  console.log(a);
  console.log(b);
  a = "123";
}
a = 18;
f1(); // undefined 9

// ------

f1();
console.log(c);
console.log(b);
console.log(a);
function f1() {
  var a = (b = c = 9);
  console.log(a);
  console.log(b);
  console.log(c);
}
// 相当于以下代码
function f1() {
  var a = (b = c = 9);
  // 相当于 var a = 9; b = 9; c = 9;  b和c直接赋值，没有声明 当 全局变量看
  // 集体声明 var a = 9,b = 9,c =9 ;
  console.log(a); //9
  console.log(b); //9
  console.log(c); //9
}
f1();
console.log(c); //9
console.log(b); //9
console.log(a); //undefined
```

## 12 对象

- 为什么需要对象
- 使用字面量创建对象
- 使用构造函数创建对象
- 说出 new 的执行过程
- 如何遍历对象

### 12.1 对象导读

#### 12.1.1 什么是对象

现实生活中 ∶ 万物皆对象，对象是**一个具体的事物**，看得见摸得着的实物。例如，一本书、一辆汽车、一个人可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。

在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。

对象是由`属性`和`方法`组成的。

- 属性 ∶ 事物的`特征`，在对象中用`属性`来表示(常用名词)
- 方法 ∶ 事物的`行为`，在对象中用`方法`来表示(常用动词)

#### 12.1.2 为什么需要对象

保存一个值时，可以使用`变量`，保存多个值(一组值)时，可以使用`数组`。如果要保存一个人的完整信息呢?

**JS 中的对象表达结构更清晰，更强大。**

### 12.2 创建对象的三种方式

在 JavaScript 中，现阶段我们可以采用三种方式创建对象( object ) :

- 利用`字面量`创建对象
- 利用`new Object`创建对象
- 利用`构造函数`创建对象

#### 12.2.1 利用字面量创建对象

`对象字面量`:就是`花括号{}`里面包含了表达这个具体事物（对象）的属性和方法。

{}里面采取键值对的形式表示

- 键 ∶ 相当于属性名
- 值 ∶ 相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等)

**利用对象字面量创建对象**

1. 对象里面的属性或者方法采用键值对的形式 键 属性名 ： 值 属性值
2. 多个属性或者方法中间有逗号隔开
3. 方法冒号后面是一个匿名函数

```js
let obj = {};
let obj1 = {
  uname: "zhangsan",
  age: 18,
  sex: "男",
  sayHi: function () {
    console.log("你好");
  },
};
```

**使用对象**

1. 调用对象的属性 我们采用 对象名.属性名
2. 另一种使用方式 对象名['属性名']
3. 调用对象的方法 对象名.方法名()

```js
console.log(obj1.age); // 18
console.log(obj1["uname"]); //zhangsan
obj1.sayHi(); // 你好
```

**变量、属性、函数、方法的区别**

- 变量和属性的相同：都是用来存储数据的

  - 变量：单独声明并赋值，使用的时候直接写变量名，单独存在。
  - 属性：在对象里面，不需要声明，使用时需要 对象.属性

- 函数和方法的相同点 都是实现某种功能：做某件事
  - 函数是单独声明并且调用的 函数名() 单独存在的
  - 方法在对象里面，调用的时候 对象.方法()

#### 12.2.2 利用 new Object 创建对象

跟 new Array() 相似

利用 new Object 创建对象

```js
let obj3 = new Object();
obj3.uname = "章安奉";
obj3.age = 25;
obj3.sex = "male";
obj3.sayHi = function () {
  console.log("hi");
};
console.log(obj3.uname); // 章安奉

console.log(obj3.sayHi()); // hi
```

1. 利用等号赋值的方法 添加对象的属性和方法
2. 每个属性和方法之间用分号结束

#### 12.2.3 利用构造函数创建对象

> 为什么需要使用构造函数？==》就是因为之前两种创建对象的方式只能一次创建一个对象

我们一次创建一个对象，里面的很多属性和方法是大量相同的，只能复制。因此我们可以利用函数的方法，重复这些相同的代码 我们称这个函数为`构造函数`。又因为这个函数不一样，里面封装的不是普通代码，而是对象。

`构造函数`︰是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。

```js
// 构造函数的语法格式
/* 
function 构造函数名(){
  this.属性 = 值
  this.方法 = function(){}
}
new 构造函数名();
*/
function Star(uname, age, sex) {
  this.uname = uname;
  this.age = age;
  this.sex = sex;
  this.sing = function (sang) {
    console.log(sang);
  };
}
let ldh = new Star("ldh", 188, "nan"); //调用函数返回的是一个对象
console.log(ldh.age);
ldh.sing("冰雨");
let zxy = new Star("zxy", 125, "nan"); //调用函数返回的是一个对象
```

1. 构造函数名字首字母要大写
2. 构造函数不需要 return 就可以返回结果
3. 我们调用构造函数时必须使用 new
4. 我们只要 new Star() 就调用函数生成一个对象
5. 我们的属性和方法前面必须添加 this

#### 12.2.4 构造函数和对象的区别

- `构造函数`：泛指的某一大类
- `对象`：是一个具体的事物，特指某一个

**我们利益构造函数创建对象的过程也称作为对象的实例化**

### 12.3 new 关键字

new 关键字执行的过程

1. new 构造函数可以在内存中创建了一个空对象
2. this 就会指向刚才创建的空对象
3. 执行构造函数里面的代码给这个空对象添加属性和方法
4. 返回这个对象，所以构造函数不需要 return。

### 12.4 遍历对象属性

`for...in语句`用于对数组或者对象的属性进行循环操作

```js
let teacher = {
  name: "pink",
  age: 25,
  sex: "male",
};

console.log(teacher.name);
console.log(teacher.age);
console.log(teacher.sex);

// for...in 遍历对象
for (let key in teacher) {
  console.log(key); //nam age sex key得到的是属性名
  console.log(teacher[key]); // 25 sex male 属性值
}
```

---

**\*总结**

1. 对象可以让代码结构更清晰
2. 对象复杂数据类型 Object
3. 本质：对象就是一组无序数组的相关属性和方法的集合
4. 构造函数泛指某一大类
5. 对象特指某一个事物
6. `for...in语句`用于对数组或者对象的属性进行循环操作

## 13 内置对象

- 能够说出什么是内置对象
- 能够根据文档查询指定 API 的使用方法
- 能够使用 Math 对象的常用方法
- 能够使用 Date 对象的常用方法
- 能够使用 Array 对象的常用方法
- 能够使用 String 对象的常用方法

### 13.1 内置对象简介

JavaScript 中的对象分为 3 种:`自定义对象`、`内置对象`、`浏览器对象`

前面两种对象是 JS 基础内容，属于`ECMAScript`;**第三个浏览器对象属于我们 JS 独有的，我们 JS API 讲解**

`内置对象`就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能(属性和方法)

JavaScript 提供了多个内置对象 ∶`Math`、 `Date` 、`Array`、`String`等

### 13.2 文档查阅

#### 13.2.1 MDN

`MDN`:https://developer.mozilla.org/zh-CN/

学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过 MDN/W3C 来查询。

Mozilla 开发者网络(MDN )提供了有关开放网络技术(Open Web )的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。

#### 13.2.2 如何学习对象中的方法

1. 查阅该方法的功能
2. 查看里面参数的意义和类型
3. 查看返回值的意义和类型
4. 通过 demo 进行测试

### 13.3 Math 对象

#### 13.3.1 Math 概述

Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。

> Math.PI //圆周率

> Math.floor () //向下取整

> Math.ceil() //向上取整

> Math.round () //四舍五入版就近取整注意-3.5 结果是-3

> Math.abs () //绝对值

> Math.max () /Math.min() //求最大和最小值

```js
console.log(Math.PI); //3.141592653589793

console.log(Math.max(1, 2, 6, 5)); //6

console.log(Math.abs(1)); //1
console.log(Math.abs(-1)); //1
console.log(Math.abs("-1")); //1 隐式转换
console.log(Math.abs("number")); //NaN

//三个取整方法
console.log(Math.floor(1.1)); //1 向下取整
console.log(Math.ceil(1.1)); //2 向上取整
console.log(Math.round(1.5)); //2 四舍五入
console.log(Math.round(-1.5)); //-1 四舍五入 其他数字都是四舍五入但是.5特殊它往大了取
```

#### 13.3.2 随机数方法 random()

Math.random()函数返回一个浮点，伪随机数在范围[0，1]，也就是说，从 0（包括 0）往上，但是不包括 1(排 1 )，然后您可以缩放到所需的范围。实现将初始种子选择到随机数生成算法;它不能被用户选择或重置。

```js
//Math.random()
/* 
Math对象随机数方法random()返回一个随机的小数0 =<x <1
这个方法里面不跟参数
*/
console.log(Math.random()); //0.8577023374955108 Math.floor (Math.random()(max - min + 1))+ min;
// 我们想要得到两个数之间的随机整数并且包含这2个整数
function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
console.log(getRandom(1, 10)); //9
```

### 13.4 日期对象

#### 13.4.1 Date 概述

创建`Date实例`用来处理日期和时间 Date 对象基于 1970 年 1 月 1 日(世界标准时间)起的毫秒数。

`Date() 日期对象`是一个构造函数必须使用 new 来调用创建我们的日期对象

#### 13.4.2 Date()方法的使用

1. 获取当前时间必须实例化

```js
let date = new Date();
console.log(date); //2023-03-28T10:52:19.981Z
```

2. Date()构浩函数的参数

```js
/* 
1.如果没有参数返回当前系统的当前时间
2.参数常用的写法 
  数字型 2019,10,01 或者字符串型 2019-10-1 8:8:8
*/
let date2 = new Date(2023, 3, 28);
console.log(date2); //2023-04-27T16:00:00.000Z
let date3 = new Date("2023-3-28 18:58");
console.log(date3); //2023-03-28T10:58:00.000Z
```

#### 13.4.3 日期格式化

需要获取日期指定的部分，所以我们要手动的得到这种格式

![](https://img2023.cnblogs.com/blog/2332774/202303/2332774-20230328190502103-457468143.png)

```js
console.log(new Date().getFullYear()); //2023
console.log(new Date().getMonth()); //2 返回的月份需要加1
console.log(new Date().getDate()); //28
console.log(new Date().getDay()); //2 星期几 周日为0
console.log(new Date().getHours()); //时 19
console.log(new Date().getMinutes()); //分 20
console.log(new Date().getSeconds()); //秒 4

console.log(
  "现在是" +
    new Date().getFullYear() +
    "年" +
    `${new Date().getMonth() + 1}` +
    "月" +
    new Date().getDate() +
    "日" +
    "星期" +
    `${new Date().getDay() === 0 ? "天" : new Date().getDay()}` +
    new Date().getHours() +
    "时" +
    new Date().getMinutes() +
    "分" +
    new Date().getSeconds() +
    "秒"
); //现在是2023年3月28日星期2 19时23分32秒
```

#### 13.4.4 获取日期的总的毫秒形式

**Date 对象是基于 1970 年 1 月 1 日(世界标准时间)起的毫秒数**

我们经常利用总的毫秒数来计算时间，因为它更精确。

```js
//获取时间秒/时间戳
let now = new Date();
console.log(now.valueOf()); //1680002943153
console.log(now.getTime()); //1680002964760
let now1 = +new Date();
console.log(now1); //1680003021052
//h5 新增的获得总的毫秒数
console.log(Date.now()); //1680003087320
```

```js
//倒计时案例
//倒计时
function countDown(time) {
  let nowTime = +new Date(); //当前时间毫秒数
  let inputTime = +new Date(time); //用户输入毫秒数
  let tims = (inputTime - nowTime) / 1000; //剩余时间毫秒
  let day = parseInt(tims / 60 / 60 / 24);
  let hour = parseInt((tims / 60 / 60) % 24);
  let m = parseInt((tims / 60) % 24);
  let s = parseInt(tims % 60);
  return day + "天" + hour + "时" + m + "分" + s + "秒";
}
console.log("距离倒计时还有：", countDown("2023-3-28 19:50:00")); //0天0时2分33秒
```

### 13.5 数组对象

#### 13.5.1 数组对象的创建

创建数组对象的两种方式

- 字面量方式
- new Array()

```js
//1. 利用数组的字面量
let arr = [1, 2, 3];
console.log(arr[2]); //3
//2. 利用new Array()
let arr1 = new Array(2); //创建一个长度为2的数组，里面有两个空元素。
console.log(arr1); //[ <2 empty items> ]
let arr2 = new Array(2, 3);
console.log(arr2); //[ 2, 3 ] 等价于创建[2,3]
```

#### 13.5.2 检测是否为数组

```js
let arrIns = [];
let arr1Ins = {};
console.log(arrIns instanceof Array); //true
console.log(arr1Ins instanceof Array); //false

//2. Array.isArray()
console.log(Array.isArray(arrIns)); //true
console.log(Array.isArray(arr1Ins)); //false
```

#### 13.5.3 添加删除数组元素的方法

| 方法名             | 说明                                                    | 返回值             |
| ------------------ | ------------------------------------------------------- | ------------------ |
| push(参数 1...)    | 末尾添加一个或多个元素，注意修改原数组                  | 并返回新的长度     |
| pop()              | 删除数组最后一个元素，把数组长度减 1 无参数、修改原数组 | 返回它删除的元素值 |
| unshift(参数 1...) | 向数组的开头添加一个或更多元素，注意修改原数组          | 返回新的长度       |
| shift()            | 别除数组的第一个元素，数组长度减 1 无参数、修改原数组   | 并返回第一个元素   |

1. push() 在我们的数组末尾添加一个或多个元素

```js
let arrPush = [1, 2, 3];
arrPush.push(4, "blue");
console.log(arrPush.push(5, "pink")); //7
console.log(arrPush); // [ 1, 2, 3, 4, 'blue' , 5, 'pink']
```

- push()可以给数组追加新的元素
- push()参数直接写数组元素就可以了
- push()完毕后返回的结果是新数组的长度
- push()完毕后原数组也会发生变化

2. unshift() 在我们数组的开头添加一个或多个元素

```js
let arrUnshift = [1, 2, 3];
arrUnshift.unshift("loop", "pop");
console.log(arrUnshift); //[ 'loop', 'pop', 1, 2, 3 ]
```

- unshift()可以给数组前面追加新的元素
- unshift()参数直接写数组元素就可以了
- unshift()完毕后返回的结果是新数组的长度
- unshift()完毕后原数组也会发生变化

3. pop() 删除数组的最后一个元素

```js
let arrPop = [1, 2, 3];
arrPop.pop();
console.log(arrPop); //[ 1, 2 ]
console.log(arrPop.pop()); //2
```

- pop()可以删除数组的最后一个元素记住一次只能删除一个元素
- pop()没有参数
- pop()完毕后返回的结果是删除的那个元素
- pop()完毕后原数组也会发生变化

4. shift() 删除数组的第一一个元素

```js
let arrShift = [1, 2, 3];
arrShift.shift();
console.log(arrShift); //[ 2, 3 ]
console.log(arrPop.shift()); //1
```

- 1. shift()可以删除数组的第一个元素记住一次只能删除一个元素
- 2. shift()没有参数
- 3. shift()完毕后返回的结果是删除的那个元素
- 4. shift()完毕后原数组也会发生变化

#### 13.5.4 数组排序

| 方法名    | 说明                       | 是否修改原数组                   |
| --------- | -------------------------- | -------------------------------- |
| reverse() | 颠倒数组中元素的顺序无参数 | 该方法会改变原来的数组返回新数组 |
| sort()    | 对数组的元素进行排序       | 该方法会改变原来的数组返回新数组 |

```js
let reArr = [9, 8, 7];
reArr.reverse();
console.log(reArr); //[ 7, 8, 9 ]
```

```js
let sortArr = [5, 19, 13, 18, 12];
sortArr.sort(function (a, b) {
  return a - b; // 按照升序的方式
});
console.log(sortArr); //[ 5, 12, 13, 18, 19 ]
```

#### 13.5.5 数组索引方法

| 方法名        | 说明                       | 是否修改原数组                       |
| ------------- | -------------------------- | ------------------------------------ |
| indexOf()     | 数组中查找给定的第一个元素 | 如果存在返回索引号如果不存在则返回-1 |
| lastIndexOf() | 在数组的最后一个索引       | 如果存在返回索引号如果不存在则返回-1 |

```js
let indexOfArr = [78, 98, 635, 12, 54, 58, 68, 58];
console.log(indexOfArr.indexOf(58)); //5 只返回第一个满足条件的索引号
console.log(indexOfArr.indexOf(528)); // -1
```

```js
let lastIndefOfArr = [1, 5, 8, 6, 78, 5, 87, 1, 1, 1];
console.log(lastIndefOfArr.lastIndexOf(1)); //9 只返回最后一个满足条件的索引号
console.log(lastIndefOfArr.lastIndexOf(158)); //-1
```

**数组去重**

- 目标︰把旧数组里面不重复的元素选取出来放到新数组中，重复的元素只保留一个，放到新数组中去重。
- 核心算法︰我们遍历旧数组，然后拿着旧数组元素去查询新数组，如果该元素在新数组里面没有出现过，我们就添加，否则不添加。

```js
let repetitiveStringArr = [
  "a",
  "b",
  "y",
  "a",
  "a",
  "u",
  "a",
  "a",
  "i",
  "n",
  "a",
  "f",
  "g",
];

function uniqueArr(arr) {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
    console.log(newArr.indexOf(arr[i]) === -1, arr[i]);
    if (newArr.indexOf(arr[i]) === -1) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}
let demo = uniqueArr(repetitiveStringArr);
console.log(demo); //['a', 'b', 'y','u', 'i', 'n','f', 'g']
```

#### 13.5.5 数组转换为子字符串

| 方法名         | 说明                                       | 是否修改原数组 |
| -------------- | ------------------------------------------ | -------------- |
| toString()     | 把数组转换成字符串逗号分隔每一项           | 返回一个字符串 |
| join('分隔符') | 方法用于把数组中的所有元素转换成一个字符串 | 返回一个字符串 |

```js
let stringArr = ["s", "t", "r"];
console.log(stringArr.toString()); //s,t,r
console.log(stringArr.join("*")); //s*t*r
```

#### 13.5.6 数组转换为子字符串

| 方法名   | 说明                                   | 返回值                                       |
| -------- | -------------------------------------- | -------------------------------------------- |
| splice() | 数组删除 splice(第几个开始,要删除个数) | 返回被删除项目的新数组注意，这个会影响原数组 |
| concat() | 连接两个或多个数组不影响原数组         | 返回一个新的数组                             |
| slice()  | 数组截取 slice(begin, end)             | 返回被截取项目的新数组                       |

slice()和 splice()目的基本相同，建议重点看下 splice()

### 13.6 字符串对象

#### 13.6.1 基本包装类型

为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型:String、Number 和 Boolean.

**基本包装类型**就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。

```js
let str59 = "andy";
console.log(str59.length); //4
```

> 为什么简单类型会有属性呢?

基本包装类型：就是把简单数据类型包装成为了复杂数据类型,步骤如下：

```js
//1.把简单数据类型包装为复杂数据类型
let temp = new String("andy");
//2.把临时变量的值给str
str59 = temp;
//3.销毁临时变量temp
temp = null;
let str59 = "andy";
```

#### 13.6.2 字符串的不可变

指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。

```js
//字符串的不可变性
let str758 = "pinnk";
console.log(str758);
str758 = "red";
console.log(str758);
//虽然值变了，但是开辟了新的内存空间，因此不要大量的拼接字符串

let str800 = "";
for (let i = 1; i < 1000000; i++) {
  str800 += i;
}
console.log(str800); //会特别卡，因为需要不断地开辟新空间
```

#### 13.6.3 根据字符返回位置

字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串。

| 方法名                             | 说明                                                                          | 返回值                           |
| ---------------------------------- | ----------------------------------------------------------------------------- | -------------------------------- |
| indexOf(要查找的位置,[起始的位置]) | 返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是 index 索引号 | 返回一个字符所在位置找不到返回-1 |
| lastIndexOf()                      | 从后往前找，只找第一个匹配的                                                  | 回一个字符所在位置找不到返回-1   |

```js
let str810 = "sdhajsdhjasdhajk";
console.log(str810.indexOf("a")); //3
console.log(str810.indexOf("a", 5)); //9 (包括有一个可选参数，确定查找的位置)
```

```js
//查找字符串中'adasdasmoasdasdowqodoasdqwo'所以有 o 出现的位置及次数
/* 
1.核心算法︰先查找第一个o出现的位置
2.然后只要indexOf返回的结果不是-1就继续往后查找
3.因为indexOf只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找
*/
let str1936 = "adasdasmoasdasdowqodoasdqw";
let index1936 = str1936.indexOf("o");
let num1941 = 0;
while (index1936 !== -1) {
  num1941++;
  index1936 = str1936.indexOf("o", index1936 + 1);
}
console.log(index1936, num1941); // -1 5
```

#### 13.6.4 根据位置返回字符

| 方法名            | 说明                                        | 使用              |
| ----------------- | ------------------------------------------- | ----------------- |
| charAt(index)     | 返回指定位置的字符(index 字符串的索引号)    | str.charAt(0)     |
| charCodeAt(index) | 获取指定位置处字符的 ASCII 码(index 索引号) | str.charCodeAt(0) |
| str[index]        | 获取指定位置处字符                          | HTML5 支持        |

```js
// 1.charAt 根据位置返回字符
console.log(str1936.charAt(3)); //s
// 遍历所有的字符
for (let i = 0; i < str1936.length; i++) {
  console.log(str1936.charAt(i));
}
// 2.charCodeAt(index) 返回相应索引号的字符ACSII码 判断用户按下了哪个键
console.log(str1936.charCodeAt(8)); //111
//3. str[index]
console.log(str1936[3]); //s
```

> 判断一个字符串'abcoefoxyozzopp'中出现次数最多的字符，并统计其次数。

1. 核心算法:利用 charAt() 遍历这个字符串
2. 把每个字符都存储给对象，如果对象没有该属性，就为 1，如果存在了就+1
3. 遍历对象，得到最大值和该字符

```js
let str009 = "abcoefoxyozzopp";
let obj009 = {};
for (let i = 0; i < str009.length; i++) {
  let chars = str009.charAt(i);
  if (obj009[chars]) {
    obj009[chars]++;
  } else {
    obj009[chars] = 1;
  }
}
console.log(obj009); //{ a: 1, b: 1, c: 1, o: 4, e: 1, f: 1, x: 1, y: 1, z: 2, p: 2 }
let max016 = 0;
let char018 = "";
for (let k in obj009) {
  if (obj009[k] > max016) {
    max016 = obj009[k];
    char018 = k;
  }
}
console.log("出现次数最多的字符是：" + char018, "，共：" + max016); // 出现次数最多的字符是：o ，共：4
```

#### 13.6.5 字符串操作方法(重点)

| 方法名                               | 说明                                                                          | 使用 |
| ------------------------------------ | ----------------------------------------------------------------------------- | ---- |
| contact(s1,s2,s3)                    | concat()方法用于连接两个或多个字符串。拼接字符串，等效于+，+更常用            |      |
| substr(start,length)                 | 从 start 位置开始(索引号), length 取的个数重点记住这个                        |      |
| slice(start,end)                     | 从 start 位置开始(索引号), length 取的个数重点记住这个                        |      |
| substring(start,end)                 | 从 start 位置开始，截取到 end 位置，end 取不到基本和 slice 相同但是不接受负值 |      |
| replace('被替换的字符','替换为字符') | 替换字符串 replace('被替换的字符','替换为字符') 只会替换第一个字符            |      |
| split('分隔符')                      | 字符串转为数组 split('分隔符')                                                |      |

- concat()方法用于连接两个或多个字符串。拼接字符串，等效于+，+更常用

```js
let str0341 = "andy";
console.log(str0341.concat("-hello")); //andy-hello
```

- substr('截取的起始位置','截取几个字符')

```js
let str036 = "改革春风满地";
console.log(str036.substr(2, 2)); //春风
```

- 替换字符串 replace('被替换的字符','替换为字符') 只会替换第一个字符

```js
let str039 = "andya";
console.log(str039.replace("a", "b")); //bndya
// 有一个字符串'sdasdqwwedsfcdsgdfsg'把里面的所有s换为*
let str045 = "sdasdqwwedsfcdsgdfsg";
while (str045.indexOf("s") !== -1) {
  str045 = str045.replace("s", "*");
}
console.log(str045); //*da*dqwwed*fcd*gdf*g
```

- 字符串转为数组 split('分隔符') 前面我们学过 join 把数组转换为字符串

```js
let str051 = "red,pink,blue";
console.log(str051.split(",")); //[ 'red', 'pink', 'blue' ]
```

## 14 Javascript中的简单数据类型与复杂数据类型

- 能够说出简单数据类型的内存分配
- 能够说出复杂教据类型的内存分配
- 能够说出简单类型如何传参
- 能够说出复杂类型如何传参

### 14.1 简单类型与复杂类型

简单类型又叫做`基本数据类型`或者`值类型`，复杂类型又叫做`引用类型`。

- 值类型∶简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型

>string , number , boolean , undefined , null

- 引用类型︰复杂数据类型，在存储时变量中存储的仅仅是地址(引用)，因此叫做引用数据类型

> 通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等

### 14.2 堆和栈

堆栈空间分配区别:
1. 栈(操作系统)︰由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈;**简单数据类型存放到栈里面**

2. 堆(操作系统)︰存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。**复杂数据类型存放到堆里面**

>注意︰JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言

### 14.3 简单类型的内存分配

- 值类型(简单数据类型) : string , number , boolean , undefined , null
- 值类型变量的数据直接存放在变量(栈空间)中

1. 简单数据类型 是存放在栈里面 里面直接开辟一个空间存放的是值

2. 复杂数据类型 首先在栈里面存放地址 十六进制表示 然后指向堆里面的数据

### 14.4 简单类型传参

函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。

```js
function fn(a) {
  a++;
  console.log(a);
}

var x = 10;
fn(x);
console.log(x); // 11 10
```

### 14.5 复杂类型传参

函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。

```js
var x = 10;
fn(x);
console.log(x); // 11 10

function Person(name) {
  this.name = name;
}

function f1(x) {
  console.log(x.name); //ldh
  x.name = "zxy";
  console.log(x.name); //zxy
}
var p = new Person("ldh");
console.log(p.name); //ldh
f1(p);
console.log(p.name);//zxy
```

## 14 Web APIs

### 14.1 Web APIs简介

能够说出Web APIs阶段与JavaScript语法阶段的关联性

能够说出什么是API

能够说出什么是 Web API

### 14.2 Web APIs和JS基础关联性

#### 14.2.1 JS的组成

![](https://img2023.cnblogs.com/blog/2332774/202307/2332774-20230704073955568-1129802340.png)

#### 14.2.2 基础阶段以及Web APIs阶段

**JS基础阶段**

- 我们学习的是 ECMAscript标准规定的基本语法
- 要求同学们掌握Js 基础语法
- 只学习基本语法，做不了常用的网页交互效果
- 目的是为了Js后面的课程打基础、做铺垫

**Web APIs**

- web APIs是w3c组织的标准
- web APIs 我们主要学习DOM和BOM
- web APIs是我们Js 所独有的部分
- 我们主要学习页面交互功能
- 需要使用Js基础的课程内容做基础

Js基础学习ECMAscript 基础语法为后面作铺垫，web APIs是Js的应用，大量使用Js 基础语法做交互效果

### 14.3 API和Web API

#### 14.3.1 API

**APl ( Application Programming Interface,应用程序编程接口)**是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

简单理解︰**API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。**

#### 14.3.2 Web API

**Web API是浏览器**提供的一套操作**浏览器功能**和**页面元素**的**API**( BOM和DOM)。

现阶段我们主要针对于浏览器讲解常用的API，主要针对浏览器做交互效果。

> https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Introduction

因为Web API很多，所以我们将这个阶段称为**Web APIs**

#### 14.3.2 API和Web API总结

1. **API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现**
2. Web API主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。
3. Web API一般都有输入和输出(函数的传参和返回值)，WebAPI很多都是方法(函数)
4. 学习Web API可以结合前面学习内置对象方法的思路学习

### 14.4 DOM

- 能够说出什么是DOM
- 能够获取页面元素
- 能够给元素注册事件
- 能够操作DOM元素的属性能够创建元素
- 能够操作DOM节点

#### 14.4.1 DOM简介

##### 14.4.1.1 什么是DOM

文档对象模型(Document Object Model，简称**DOM**)，是W3C组织推荐的处理可扩展标记语言( HTML或者XML)的**标准编程接口**。

w3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。

##### 14.4.1.2 DOM树

![](https://img2023.cnblogs.com/blog/2332774/202307/2332774-20230704075911651-1709441007.png)

- 文档:一个页面就是一个文档，DOM中使用document表示
- 元素:页面中的所有标签都是元素，DOM中使用element表示
- 节点︰网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示

**DOM把以上内容都看做是对象**

#### 14.4.2 获取元素

##### 14.4.2.1 如何获取页面元素

DOM在我们实际开发中主要用来操作元素。我们如何来获取页面中的元素呢?

获取页面中的元素可以使用以下几种方式:

- 根据ID获取
- 根据标签名获取
- 通过HTML5新增的方法获取
- 特殊元素获取

##### 14.4.2.2 根据ID获取

使用`getElementByld()`方法可以获取带有ID的元素对象。

```js
let div = document.getElementById("div");
console.log({ div });
console.dir(div);
```

1. 因为我们文档页面从上往下加载，所以先得有标签所以我们script写到标签的下面
2. get 获得 element 元素 by 通过驼峰命名法
3. 参数 id 是大小写敏感的字符串
4. 返回的是一个对象
5. console.dir 打印我们返回的对象，更好的查看里面的属性和方法
      
##### 14.4.2.3 根据标签名获取

使用getElementsByTagName()方法可以返回带有指定标签名的**对象的集合**。

```js
let li = document.getElementsByTagName("li");
console.log(li); 
console.log(li[0]);
// 2. 我们想要依次打印里面的元素对象我们可以采用遍历的方式
for (let i = 0; i < li.length; i++) {
  console.log(li[i]);
}
```
注意:

1. 返回的是获取过来元素对的集合，以伪数组的形式存在。
2．因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。
3. 得到元素对象是动态的
4. 如果页面中只有一个li，返回的还是伪数组的形式。
5. 如果页面中没有一个li，返回的还是一个空的伪数组。

---

还可以获取某个元素(父元素)内部所有指定标签名的子元素.

> element.getElementsByTagName ('标签名');

注意∶父元素必须是**单个对象(必须指明是哪一个元素对象)**,获取的时候不包括父元素自己。

```js
let ol = document.getElementsByTagName("ol");
console.log(ol[0].getElementsByTagName("li"));
```
 
##### 14.4.2.4 通过 HTML5 新增的方法获取

1. document.getElementsByClassName( '类名' );
>根据类名返回元素对象集合
```js
let boxs = document.getElementsByClassName("box");
```

2. document.query selector ( '选择器');
> 根据指定选择器返回第一个元素对象
**切记里面的选择器需要加符号 .box #nav**
```js
let box1 = document.querySelector(".box");
```

3. document.queryselectorAll('选择器');
>根据指定选择器返回
```js
let allBox = document.querySelectorAll(".box");
```

##### 14.4.2.5 获取特殊元素(body,html)

1. 获取body元素
```js
let body = document.body;
```

2. 获取html元素
```js
let html = document.documentElement;
```